{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ISO Week Date","text":"<p>iso-week-date is a toolkit to work with strings representing ISO Week date in two formats, namely:</p> <ul> <li>Week format YYYY-WNN (date format %Y-W%V)</li> <li>Week date format YYYY-WNN-D (date format %Y-W%V-%u)</li> </ul> <p>where YYYY represents the year, W is a string literal, NN represents the week number, and D represents the day of the week.</p> <p>In a nutshell it provides:</p> <ul> <li><code>IsoWeek</code> and <code>IsoWeekDate</code> classes that implement a series of methods to work with ISO Week (Date) formats directly, avoiding the pitfalls of going back and forth between string, date and datetime python objects.</li> <li>pandas and polars functionalities (and namespaces) to work with series of ISO Week dates.</li> <li>pydantic compatible types, as described in their docs section on how to customize validation with <code>__get_pydantic_core_schema__</code></li> </ul> <p>Documentation | Source Code | Issue Tracker</p>"},{"location":"#installation","title":"Installation","text":"<p>TL;DR: you can install the package with pip:</p> <pre><code>python -m pip install iso-week-date\n</code></pre> <p>For more information please refer to the installation section.</p>"},{"location":"#usage","title":"Usage","text":"<p>To get started with <code>IsoWeek</code> and <code>IsoWeekDate</code> classes please refer to the quickstart section.</p> <p>To check examples on how to work with pandas and polars functionalities please refer to the dataframe modules section.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Please read the contributing guidelines in the documentation site.</p>"},{"location":"#license","title":"License","text":"<p>The project has a MIT Licence.</p>"},{"location":"contribute/","title":"Contributing","text":""},{"location":"contribute/#guidelines","title":"Guidelines","text":"<p>We welcome contributions to the library! If you have a bug fix or new feature that you would like to contribute, please follow the steps below:</p> <ol> <li>Fork the repository on GitHub.</li> <li>Clone the repository to your local machine.</li> <li>Create a new branch for your bug fix or feature.</li> <li>Make your changes and test them thoroughly, making sure that it passes all current tests.</li> <li>Commit your changes and push the branch to your fork.</li> <li>Open a pull request on the main repository.</li> </ol>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the project's code of conduct, which is based on the Contributor Covenant.</p>"},{"location":"contribute/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in the library, please report it by opening an issue on GitHub. Be sure to include the version of the library you're using, as well as any error messages or tracebacks and a reproducible example.</p>"},{"location":"contribute/#requesting-features","title":"Requesting Features","text":"<p>If you have a suggestion for a new feature, please open an issue on GitHub. Be sure to explain the problem that you're trying to solve and how you think the feature would solve it.</p>"},{"location":"contribute/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>When submitting a pull request, please make sure that you've followed the steps above and that your code has been thoroughly tested. Also, be sure to include a brief summary of the changes you've made and a reference to any issues that your pull request resolves.</p>"},{"location":"contribute/#code-formatting","title":"Code formatting","text":"<p>iso-week-date uses ruff as linter and formatter:</p> with makewithout make <pre><code>make lint\n</code></pre> <pre><code>ruff check iso_week_date tests --fix\nruff format iso_week_date tests\n</code></pre> <p>As part of the checks on pull requests, it is checked whether the code follows those standards. To ensure that the standard is met, it is recommended to install pre-commit hooks:</p> <pre><code>python -m pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contribute/#developing","title":"Developing","text":"<p>Let's suppose that you already did steps 1-3 from the above list, now you should install the library and its developing dependencies  in editable way.</p> <p>First move into the repo folder: <code>cd iso-week-date</code>.</p> <p>Then:</p> with makewithout make <pre><code>make init-dev\n</code></pre> <pre><code>pip install -e \".[all-dev]\" --no-cache-dir\npre-commit install\n</code></pre> <p>Now you are ready to proceed with all the changes you want to!</p>"},{"location":"contribute/#testing","title":"Testing","text":"<p>Once you are done with changes, you should:</p> <ul> <li>add tests for the new features in the <code>/tests</code> folder</li> <li> <p>make sure that new features do not break existing codebase by running tests:</p> with makewithout make <pre><code>make test\n</code></pre> <pre><code>pytest tests -vv\n</code></pre> </li> </ul>"},{"location":"contribute/#docs","title":"Docs","text":"<p>The documentation is generated using mkdocs-material, the API part uses mkdocstrings.</p> <p>If a breaking feature is developed, then we suggest to update documentation in the <code>/docs</code> folder as well, in order to describe how this can be used from a user perspective.</p>"},{"location":"installation/","title":"Installation","text":"<p>iso-week-date is published as a Python package on pypi, and it can be installed with pip, or directly from source using git, or with a local clone:</p> pip (pypi)source/gitlocal clone <pre><code>python -m pip install iso-week-date\n</code></pre> <pre><code>python -m pip install git+https://github.com/FBruzzesi/iso-week-date.git\n</code></pre> <pre><code>git clone https://github.com/FBruzzesi/iso-week-date.git\ncd iso-week-date\npython -m pip install .\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li>To work with <code>IsoWeek</code> and <code>IsoWeekDate</code> classes, no additional dependencies are required.</li> <li> <p>pandas, polars  and/or pydantic functionalities require the installation of the respective libraries.</p> pandaspolarspydantic <pre><code>python -m pip install \"pandas&gt;=1.0.0\"\npython -m pip install \"iso-week-date[pandas]\"\n</code></pre> <pre><code>python pip install \"polars&gt;=0.18.0\"\npython pip install \"iso-week-date[polars]\"\n</code></pre> <pre><code>python pip install \"pydantic&gt;=2.4.0\"\npython pip install \"iso-week-date[pydantic]\"\n</code></pre> </li> </ul>"},{"location":"api/isoweek/","title":"<code>IsoWeek</code> class","text":""},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek","title":"iso_week_date.isoweek.IsoWeek","text":"<p>               Bases: <code>BaseIsoWeek</code></p> <p>Represents ISO Week date in the  YYYY-WNN format.</p> <p>The class implements methods and functionalities to work directly with iso week format and avoid moving back and forth between <code>date</code>, <code>datetime</code> and <code>str</code> objects.</p> <p>Attributes:</p> Name Type Description <code>value_</code> <p>iso-week string of format \"YYYY-WNN\" where:</p> <ul> <li>YYYY is between 0001 and 9999</li> <li>W is a literal character</li> <li>NN is between 01 and 53</li> </ul> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>class IsoWeek(BaseIsoWeek):\n    \"\"\"Represents [ISO Week date](https://en.wikipedia.org/wiki/ISO_week_date) in the  _YYYY-WNN_ format.\n\n    The class implements methods and functionalities to work directly with iso week format and avoid moving back and\n    forth between `date`, `datetime` and `str` objects.\n\n    Attributes:\n        value_: iso-week string of format \"YYYY-WNN\" where:\n\n            - YYYY is between 0001 and 9999\n            - W is a literal character\n            - NN is between 01 and 53\n    \"\"\"\n\n    # Class Attributes\n\n    _pattern = ISOWEEK_PATTERN\n    _format = ISOWEEK__FORMAT\n    _date_format = ISOWEEK__DATE_FORMAT\n\n    # Properties\n\n    @property\n    def year(self: Self) -&gt; int:\n        \"\"\"Returns year number as integer.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").year\n            2025\n        \"\"\"\n        return super().year\n\n    @property\n    def week(self: Self) -&gt; int:\n        \"\"\"Returns week number as integer.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").week\n            1\n        \"\"\"\n        return super().week\n\n    @property\n    def quarter(self: Self) -&gt; int:\n        \"\"\"Returns quarter number as integer.\n\n        The first three quarters have 13 weeks, while the last one has either 13 or 14 weeks depending on the year:\n\n        - Q1: weeks from 1 to 13\n        - Q2: weeks from 14 to 26\n        - Q3: weeks from 27 to 39\n        - Q4: weeks from 40 to 52 (or 53 if applicable)\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").quarter\n            1\n            &gt;&gt;&gt; IsoWeek(\"2025-W32\").quarter\n            3\n        \"\"\"\n        return super().quarter\n\n    @property\n    def days(self: Self) -&gt; tuple[date, ...]:\n        \"\"\"Returns tuple of days (as date) in the ISO week.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; days = IsoWeek(\"2025-W01\").days\n            &gt;&gt;&gt; [str(d) for d in days]\n            ['2024-12-30', '2024-12-31', '2025-01-01', '2025-01-02', '2025-01-03', '2025-01-04', '2025-01-05']\n        \"\"\"\n        return tuple(self.to_date(weekday) for weekday in range(1, 8))\n\n    # Dunder methods\n\n    def __eq__(self: Self, other: object) -&gt; bool:\n        \"\"\"Equality operator.\n\n        Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if objects are equal, `False` otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") == IsoWeek(\"2025-W01\")\n            True\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") == IsoWeek(\"2025-W02\")\n            False\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") == CustomIsoWeek(\"2025-W01\")\n            False\n        \"\"\"\n        return super().__eq__(other)\n\n    def __ne__(self: Self, other: object) -&gt; bool:\n        \"\"\"Inequality operator.\n\n        Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if objects are _not_ equal, `False` otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") != IsoWeek(\"2025-W01\")\n            False\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") != IsoWeek(\"2025-W02\")\n            True\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") != CustomIsoWeek(\"2025-W01\")\n            True\n        \"\"\"\n        return super().__ne__(other)\n\n    def __lt__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Less than operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is less than other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; IsoWeek(\"2025-W02\")\n            True\n            &gt;&gt;&gt; IsoWeek(\"2025-W02\") &lt; IsoWeek(\"2025-W01\")\n            False\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; CustomIsoWeek(\"2025-W01\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; \"2025-W01\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__lt__(other)\n\n    def __le__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Less than or equal operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is less than or equal to other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= IsoWeek(\"2025-W02\")\n            True\n            &gt;&gt;&gt; IsoWeek(\"2025-W02\") &lt;= IsoWeek(\"2025-W01\")\n            False\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= CustomIsoWeek(\"2025-W01\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= \"2025-W01\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__le__(other)\n\n    def __gt__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Greater than operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is greater than other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; IsoWeek(\"2025-W02\")\n            False\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; IsoWeek(\"2022-W52\")\n            True\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; CustomIsoWeek(\"2025-W01\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; \"2025-W01\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__gt__(other)\n\n    def __ge__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Greater than or equal operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n           other: Object to compare with.\n\n        Returns:\n            `True` if self is greater than or equal to `other`, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= IsoWeek(\"2025-W02\")\n            False\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= IsoWeek(\"2025-W01\")\n            True\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= CustomIsoWeek(\"2025-W01\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= \"2025-W01\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__ge__(other)\n\n    def __hash__(self: Self) -&gt; int:\n        \"\"\"Returns the hash of the object.\n\n        The hash is calculated based on the `value_` attribute and the `offset_` attribute.\n        This allows for proper hashing and comparison of IsoWeek objects.\n\n        Returns:\n            Hash of the IsoWeek object.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; hash(IsoWeek(\"2025-W01\"))  # doctest: +SKIP\n            -8273429449497533691\n\n            &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; hash(CustomIsoWeek(\"2025-W01\"))  # doctest: +SKIP\n            179726044712929056\n        \"\"\"\n        return super().__hash__()\n\n    def __next__(self: Self) -&gt; Self:\n        \"\"\"Returns the next ISO week.\n\n        This is equivalent to adding 1 to the current ISO week.\n\n        Returns:\n            Next ISO week.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; next(IsoWeek(\"2025-W01\"))\n            IsoWeek(2025-W02) with offset 0:00:00\n        \"\"\"\n        return super().__next__()\n\n    def __repr__(self: Self) -&gt; str:\n        \"\"\"Custom representation.\n\n        Returns:\n            String representation of the IsoWeek object: class name, value and offset.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\")\n            IsoWeek(2025-W01) with offset 0:00:00\n        \"\"\"\n        return super().__repr__()\n\n    def __str__(self: Self) -&gt; str:\n        \"\"\"Custom string representation.\n\n        Returns:\n            String representation of the IsoWeek object in the format \"YYYY-WNN\".\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeek(\"2025-W01\"))\n            '2025-W01'\n        \"\"\"\n        return super().__str__()\n\n    # from_* methods\n\n    @classmethod\n    def from_string(cls: type[Self], _str: str, /) -&gt; Self:\n        \"\"\"Create an IsoWeek instance from a string in YYYY-WNN format.\n\n        Arguments:\n            _str: String in YYYY-WNN format.\n\n        Returns:\n            IsoWeek instance.\n\n        Raises:\n            TypeError: If `_str` is not a string.\n            ValueError: If `_str` does not match the expected format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek.from_string(\"2025-W01\")\n            IsoWeek(2025-W01) with offset 0:00:00\n            &gt;&gt;&gt; IsoWeek.from_string(\"2025-W53\")\n            Traceback (most recent call last):\n            ValueError: Invalid week number. Year 2025 has only 52 weeks.\n        \"\"\"\n        return super().from_string(_str)\n\n    @classmethod\n    def from_compact(cls: type[Self], _str: str, /) -&gt; Self:\n        \"\"\"Create an IsoWeek instance from a compact string in YYYYNN format.\n\n        Arguments:\n            _str: String in YYYYNN format.\n\n        Returns:\n            IsoWeek instance.\n\n        Raises:\n            TypeError: If `_str` is not a string.\n            ValueError: If `_str` does not match the expected format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek.from_compact(\"2025W01\")\n            IsoWeek(2025-W01) with offset 0:00:00\n            &gt;&gt;&gt; IsoWeek.from_compact(\"2025W53\")\n            Traceback (most recent call last):\n            ValueError: Invalid week number. Year 2025 has only 52 weeks.\n        \"\"\"\n        return super().from_compact(_str)\n\n    @classmethod\n    def from_date(cls: type[Self], _date: date, /) -&gt; Self:\n        \"\"\"Create an IsoWeek instance from a date object.\n\n        Arguments:\n            _date: Date object.\n\n        Returns:\n            IsoWeek instance.\n\n        Raises:\n            TypeError: If `_date` is not a date object.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek.from_date(date(2024, 12, 30))\n            IsoWeek(2025-W01) with offset 0:00:00\n        \"\"\"\n        return super().from_date(_date)\n\n    @classmethod\n    def from_datetime(cls: type[Self], _datetime: datetime, /) -&gt; Self:\n        \"\"\"Create an IsoWeek instance from a datetime object.\n\n        Arguments:\n            _datetime: Datetime object.\n\n        Returns:\n            IsoWeek instance.\n\n        Raises:\n            TypeError: If `_datetime` is not a datetime object.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek.from_datetime(datetime(2024, 12, 30))\n            IsoWeek(2025-W01) with offset 0:00:00\n        \"\"\"\n        return super().from_datetime(_datetime)\n\n    @classmethod\n    def from_today(cls: type[Self], time_zone: tzinfo | None = None) -&gt; Self:\n        \"\"\"Create an IsoWeek instance from the current date.\n\n        Returns:\n            IsoWeek instance representing the current date.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek.from_today() == IsoWeek.from_date(datetime.now().date())\n            True\n        \"\"\"\n        return cls.from_datetime(datetime.now(tz=time_zone))\n\n    @classmethod\n    def from_values(cls: type[Self], year: int, week: int) -&gt; Self:\n        \"\"\"Create an IsoWeek instance from year and week number.\n\n        Arguments:\n            year: Year number (YYYY).\n            week: Week number (NN).\n\n        Returns:\n            IsoWeek instance.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek.from_values(2025, 1)\n            IsoWeek(2025-W01) with offset 0:00:00\n            &gt;&gt;&gt; IsoWeek.from_values(2025, 53)\n            Traceback (most recent call last):\n            ValueError: Invalid week number. Year 2025 has only 52 weeks.\n        \"\"\"\n        value = cls._format.replace(\"YYYY\", str(year).zfill(4)).replace(\"NN\", str(week).zfill(2))\n        return cls(value)\n\n    # to_* methods\n\n    def to_string(self: Self) -&gt; str:\n        \"\"\"Returns as a string in the YYYY-WNN format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_string()\n            '2025-W01'\n        \"\"\"\n        return super().to_string()\n\n    def to_compact(self: Self) -&gt; str:\n        \"\"\"Returns as a string in the YYYYWNN format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_compact()\n            '2025W01'\n        \"\"\"\n        return super().to_compact()\n\n    def to_datetime(self: Self, weekday: int = 1) -&gt; datetime:\n        \"\"\"Converts `IsoWeek` to `datetime` object with the given weekday.\n\n        If no weekday is provided then the first day of the week is used.\n\n        !!! info\n            Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n        Arguments:\n            weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n                is the last day of the week.\n\n        Returns:\n            `IsoWeek` value in `datetime` type with the given weekday.\n\n        Raises:\n            TypeError: If `weekday` is not an integer.\n            ValueError: If `weekday` is not between 1 and 7.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_datetime()\n            datetime.datetime(2024, 12, 30, 0, 0)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_datetime(3)\n            datetime.datetime(2025, 1, 1, 0, 0)\n        \"\"\"\n        if not isinstance(weekday, int):\n            msg = f\"`weekday` must be an integer between 1 and 7, found {type(weekday)}\"\n            raise TypeError(msg)\n        if weekday not in range(1, 8):\n            msg = f\"Invalid `weekday`. Weekday must be between 1 and 7, found {weekday}\"\n            raise ValueError(msg)\n\n        return super()._to_datetime(f\"{self.value_}-{weekday}\")\n\n    def to_date(self: Self, weekday: int = 1) -&gt; date:\n        \"\"\"Converts `IsoWeek` to `date` object with the given `weekday`.\n\n        If no weekday is provided then the first day of the week is used.\n\n        !!! info\n            Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n        Arguments:\n            weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n                is the last day of the week.\n\n        Returns:\n            `IsoWeek` value in `date` type with the given weekday.\n\n        Raises:\n            TypeError: If `weekday` is not an integer.\n            ValueError: If `weekday` is not between 1 and 7.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_date()\n            datetime.date(2024, 12, 30)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_date(3)\n            datetime.date(2025, 1, 1)\n        \"\"\"\n        return self.to_datetime(weekday).date()\n\n    def to_values(self: Self) -&gt; tuple[int, ...]:\n        \"\"\"Returns the year and week as a tuple of integers.\n\n        Returns:\n            Tuple of integers representing the year and week.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_values()\n            (2025, 1)\n        \"\"\"\n        return super().to_values()\n\n    # arithmetic operations\n\n    @overload\n    def __add__(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def __add__(\n        self: Self,\n        other: int | Iterable[int],\n    ) -&gt; Self | Generator[Self, None, None]: ...\n\n    def __add__(\n        self: Self,\n        other: int | Iterable[int],\n    ) -&gt; Self | Generator[Self, None, None]:\n        \"\"\"Addition operation.\n\n        It supports addition with the following types:\n\n        - `int`: interpreted as number of weeks to be added to the `IsoWeek` value.\n        - `Iterable` of `int` : adds each element of the iterable to the `IsoWeek` value and returns\n            a generator of `IsoWeek` objects.\n\n        Arguments:\n            other: Object to add to `IsoWeek`.\n\n        Returns:\n            New `IsoWeek` or generator of `IsoWeek` object(s) with the result of the addition.\n\n        Raises:\n            TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeek(\"2025-W01\") + 1)\n            '2025-W02'\n            &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\") + (1, 2, 3))\n            ('2025-W02', '2025-W03', '2025-W04')\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() + timedelta(weeks=other))\n        elif isinstance(other, Iterable) and all(isinstance(_other, int) for _other in other):\n            return (self + _other for _other in other)\n        else:\n            msg = f\"Cannot add type {type(other)} to `IsoWeek`. Addition is supported with `int` type\"\n            raise TypeError(msg)\n\n    @overload\n    def add(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def add(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def add(\n        self: Self,\n        other: int | Iterable[int],\n    ) -&gt; Self | Generator[Self, None, None]: ...\n\n    def add(self: Self, other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]:\n        \"\"\"Method equivalent of addition operator `self + other`.\n\n        It supports addition with the following types:\n\n        - `int`: interpreted as number of weeks to be added to the `IsoWeek` value.\n        - `Iterable` of `int` : adds each element of the iterable to the `IsoWeek` value and returns\n            a generator of `IsoWeek` objects.\n\n        Arguments:\n            other: Object to add to `IsoWeek`.\n\n        Returns:\n            New `IsoWeek` or generator of `IsoWeek` object(s) with the result of the addition.\n\n        Raises:\n            TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeek(\"2025-W01\").add(1))\n            '2025-W02'\n            &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\").add((1, 2, 3)))\n            ('2025-W02', '2025-W03', '2025-W04')\n        \"\"\"\n        return self.__add__(other)\n\n    @overload\n    def __sub__(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def __sub__(self: Self, other: Self) -&gt; int: ...\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def __sub__(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]: ...\n\n    def __sub__(  # pyright: ignore[reportIncompatibleMethodOverride]\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]:\n        \"\"\"Subtraction operation.\n\n        It supports subtraction with the following types:\n\n        - `int`: interpreted as number of weeks to be subtracted to the `IsoWeek` value.\n        - `IsoWeek`: will result in the difference between values in weeks (`int` type).\n        - `Iterable` of `int` and/or `IsoWeek`: subtracts each element of the iterable to the `IsoWeek`.\n\n        Arguments:\n            other: Object to subtract to `IsoWeek`.\n\n        Returns:\n            Results from the subtraction, can be `int`, `IsoWeek` or Generator of `int` and/or `IsoWeek` depending\n                on the type of `other`.\n\n        Raises:\n            TypeError: If `other` is not `int`, `IsoWeek` or `Iterable` of those types.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeek(\"2025-W01\") - 1)\n            '2024-W52'\n            &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\") - (1, 2, 3))\n            ('2024-W52', '2024-W51', '2024-W50')\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") - IsoWeek(\"2024-W52\")\n            1\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\") - IsoWeek(\"2024-W51\")\n            2\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() - timedelta(weeks=other))\n        elif isinstance(other, IsoWeek) and self.offset_ == other.offset_:\n            return (self.to_date() - other.to_date()).days // 7\n        elif isinstance(other, Iterable) and all(isinstance(_other, (int, IsoWeek)) for _other in other):\n            return (self - _other for _other in other)\n        else:\n            msg = (\n                f\"Cannot subtract type {type(other)} to `IsoWeek`. \"\n                \"Subtraction is supported with `int` and `IsoWeek` types\"\n            )\n            raise TypeError(msg)\n\n    @overload\n    def sub(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def sub(self: Self, other: Self) -&gt; int: ...\n\n    @overload\n    def sub(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def sub(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...\n\n    @overload\n    def sub(\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]: ...\n\n    def sub(\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]:\n        \"\"\"Method equivalent of subtraction operator `self - other`.\n\n        It supports subtraction with the following types:\n\n        - `int`: interpreted as number of weeks to be subtracted to the `IsoWeek` value.\n        - `IsoWeek`: will result in the difference between values in weeks (`int` type).\n        - `Iterable` of `int` and/or `IsoWeek`: subtracts each element of the iterable to the `IsoWeek`.\n\n        Arguments:\n            other: Object to subtract to `IsoWeek`.\n\n        Returns:\n            Results from the subtraction, can be `int`, `IsoWeek` or Generator of `int` and/or `IsoWeek` depending\n                on the type of `other`.\n\n        Raises:\n            TypeError: If `other` is not `int`, `IsoWeek` or `Iterable` of those types.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeek(\"2025-W01\").sub(1))\n            '2024-W52'\n            &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\").sub((1, 2, 3)))\n            ('2024-W52', '2024-W51', '2024-W50')\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").sub(IsoWeek(\"2024-W52\"))\n            1\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").sub(IsoWeek(\"2024-W51\"))\n            2\n        \"\"\"\n        return self.__sub__(other)\n\n    def next(self: Self) -&gt; Self:\n        \"\"\"Method equivalent of adding 1 to the current value.\n\n        Returns:\n            Next `IsoWeek` object.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").next()\n            IsoWeek(2025-W02) with offset 0:00:00\n        \"\"\"\n        return super().next()\n\n    def previous(self: Self) -&gt; Self:\n        \"\"\"Method equivalent of subtracting 1 to the current value.\n\n        Returns:\n            Previous `IsoWeek` object.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").previous()\n            IsoWeek(2024-W52) with offset 0:00:00\n        \"\"\"\n        return super().previous()\n\n    # Specific methods\n\n    @overload\n    @classmethod\n    def range(\n        cls: type[Self],\n        start: date | datetime | str | Self,\n        end: date | datetime | str | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: Literal[True] = True,\n    ) -&gt; Generator[str, None, None]: ...\n\n    @overload\n    @classmethod\n    def range(\n        cls: type[Self],\n        start: date | datetime | str | Self,\n        end: date | datetime | str | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: Literal[False],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    @classmethod\n    def range(\n        cls: type[Self],\n        start: date | datetime | str | Self,\n        end: date | datetime | str | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: bool = True,\n    ) -&gt; Generator[str | Self, None, None]: ...\n\n    @classmethod\n    def range(  # pyright: ignore[reportIncompatibleMethodOverride]\n        cls: type[Self],\n        start: date | datetime | str | Self,\n        end: date | datetime | str | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: bool = True,\n    ) -&gt; Generator[str | Self, None, None]:\n        \"\"\"Generates `IsoWeek` (or `str`) between `start` and `end` values with given `step`.\n\n        `inclusive` parameter can be used to control inclusion of `start` and/or `end` week values.\n\n        If `as_str` is flagged as `True`, it will return str values, otherwise it will return `BaseIsoWeek` objects.\n\n        Arguments:\n            start: Starting value. It can be `IsoWeek`, `date`, `datetime` or `str`.\n            end: Ending value. It can be `IsoWeek`, `date`, `datetime` or `str`.\n            step: Step between generated values, must be positive integer.\n            inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n            as_str: Whether to return `str` or `IsoWeek` object.\n\n        Returns:\n            Generator of `IsoWeek` or `str` between `start` and `end` values with given `step`.\n\n        Raises:\n            ValueError: If any of the following conditions is met:\n\n                - `start &gt; end`.\n                - `inclusive` not one of \"both\", \"left\", \"right\" or \"neither\".\n                - `step` is not strictly positive.\n            TypeError: If `step` is not an int.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; tuple(\n            ...     IsoWeek.range(\n            ...         start=\"2025-W01\",\n            ...         end=\"2025-W07\",\n            ...         step=2,\n            ...         inclusive=\"both\",\n            ...         as_str=True,\n            ...     )\n            ... )\n            ('2025-W01', '2025-W03', '2025-W05', '2025-W07')\n        \"\"\"\n        return super().range(\n            start=start,\n            end=end,\n            step=step,\n            inclusive=inclusive,\n            as_str=as_str,\n        )\n\n    def is_before(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Checks if `self` is before `other`.\n\n        Arguments:\n            other: Other object to compare with.\n\n        Returns:\n            True if `self` is before `other`, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_before(IsoWeek(\"2025-W02\"))\n            True\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_before(IsoWeek(\"2025-W01\"))\n            False\n        \"\"\"\n        return super().is_before(other)\n\n    def is_after(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Checks if `self` is after `other`.\n\n        Arguments:\n            other: Other object to compare with.\n\n        Returns:\n            True if `self` is after `other`, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_after(IsoWeek(\"2024-W52\"))\n            True\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_after(IsoWeek(\"2025-W01\"))\n            False\n        \"\"\"\n        return super().is_after(other)\n\n    def is_between(  # pyright: ignore[reportIncompatibleMethodOverride]\n        self: Self,\n        lower_bound: Self,\n        upper_bound: Self,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n    ) -&gt; bool:\n        \"\"\"Check if `self` is between `lower_bound` and `upper_bound`.\n\n        Arguments:\n            lower_bound: Lower bound to compare with.\n            upper_bound: Upper bound to compare with.\n            inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n\n        Returns:\n            True if `self` is between `lower_bound` and `upper_bound`, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_between(IsoWeek(\"2024-W52\"), IsoWeek(\"2025-W02\"))\n            True\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_between(IsoWeek(\"2025-W01\"), IsoWeek(\"2025-W02\"), inclusive=\"neither\")\n            False\n        \"\"\"\n        return super().is_between(lower_bound=lower_bound, upper_bound=upper_bound, inclusive=inclusive)\n\n    def nth(self: Self, n: int) -&gt; date:\n        \"\"\"Returns the n-th day of the week using the ISO weekday numbering convention (1=first, .. , 7=Last day).\n\n        !!! info\n            Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n        Arguments:\n            n: Day number between 1 and 7.\n\n        Returns:\n            `date` object representing the Nth day of the week.\n\n        Raises:\n            TypeError: If `n` is not an integer.\n            ValueError: If `n` is not between 1 and 7.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").nth(1)\n            datetime.date(2024, 12, 30)\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").nth(7)\n            datetime.date(2025, 1, 5)\n        \"\"\"\n        if not isinstance(n, int):\n            msg = f\"`n` must be an integer, found {type(n)}\"\n            raise TypeError(msg)\n        if n not in range(1, 8):\n            msg = f\"`n` must be between 1 and 7, found {n}\"\n            raise ValueError(msg)\n\n        return self.days[n - 1]\n\n    @overload\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: Literal[True],\n    ) -&gt; Generator[str, None, None]: ...\n\n    @overload\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: Literal[False],\n    ) -&gt; Generator[IsoWeek, None, None]: ...\n\n    @overload\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[str | IsoWeek, None, None]: ...\n\n    def weeksout(\n        self: Self,\n        n_weeks: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[str | IsoWeek, None, None]:\n        \"\"\"Generate range of `IsoWeek` (or `str`) from one to `n_weeks` ahead of current `value`, with given `step`.\n\n        If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeek` objects.\n\n        Arguments:\n            n_weeks: Number of weeks to be generated from current value.\n            step: Step between weeks, must be positive integer.\n            as_str: Whether to return str or IsoWeek object.\n\n        Returns:\n            Generator of `IsoWeek`s (or `str`s) from one week to `n_weeks` ahead of current `value` with given `step`.\n\n        Raises:\n            TypeError: If `n_weeks` and/or `step` is not int.\n            ValueError: If `n_weeks` and/or `step` is not strictly positive.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; isoweek = IsoWeek(\"2025-W01\")\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; tuple(isoweek.weeksout(4))\n            ('2025-W02', '2025-W03', '2025-W04', '2025-W05')\n            &gt;&gt;&gt; tuple(isoweek.weeksout(4, step=2))\n            ('2025-W02', '2025-W04')\n        \"\"\"\n        if not isinstance(n_weeks, int):\n            msg = f\"`n_weeks` must be an integer, found {type(n_weeks)} type\"\n            raise TypeError(msg)\n\n        if n_weeks &lt;= 0:\n            msg = f\"`n_weeks` must be strictly positive, found {n_weeks}\"\n            raise ValueError(msg)\n\n        start, end = (self + 1), (self + n_weeks)\n        return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n\n    def __contains__(self: Self, other: Any) -&gt; bool:  # noqa: ANN401\n        \"\"\"Checks if self contains `other`.\n\n        Arguments:\n            other: `IsoWeek`, `date`, `datetime` or `str`.\n\n        Returns:\n            `True` if self week contains other, `False` otherwise.\n\n        Raises:\n            TypeError: If other is not `IsoWeek`, `date`, `datetime` or `str`.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; date(2025, 1, 2) in IsoWeek(\"2025-W01\")\n            True\n            &gt;&gt;&gt; date(2025, 1, 7) in IsoWeek(\"2025-W01\")\n            False\n        \"\"\"\n        if isinstance(other, (date, datetime, str, self.__class__)):\n            _other = self._cast(other)\n            return self.__eq__(_other)\n        else:\n            msg = f\"Cannot compare type `{type(other)}` with IsoWeek\"\n            raise TypeError(msg)\n\n    # Note: str is technically a Sequence[str], causing an overload overlap.\n    # However, at runtime, str values are handled by the first overload before\n    # being checked as a Sequence, so this is safe to ignore.\n    @overload\n    def contains(self: Self, other: date | datetime | str | Self) -&gt; bool: ...  # type: ignore[overload-overlap]\n\n    @overload\n    def contains(self: Self, other: Sequence[date | datetime | str | Self]) -&gt; tuple[bool, ...]: ...\n\n    def contains(\n        self: Self, other: date | datetime | str | Self | Sequence[date | datetime | str | Self]\n    ) -&gt; bool | tuple[bool, ...]:\n        \"\"\"Checks if self contains `other`. `other` can be a single value or an iterable of values.\n\n        In case of an iterable, the method returns a tuple of boolean values.\n\n        Arguments:\n            other: `IsoWeek`, `date`, `datetime` or `str`, or an iterable of those types.\n\n        Returns:\n            Boolean or iterable of booleans, where each boolean indicates whether self contains the corresponding value\n                in the iterable.\n\n        Raises:\n            TypeError: If other is not IsoWeek, date, datetime or str, or an iterable of those types.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeek(\"2025-W01\").contains([date(2025, 1, 1), date(2025, 1, 6)])\n            (True, False)\n        \"\"\"\n        if isinstance(other, (date, datetime, str, IsoWeek)):\n            return other in self\n        elif isinstance(other, Iterable):\n            return tuple(_other in self for _other in other)\n        else:\n            msg = f\"Cannot compare type `{type(other)}` with `IsoWeek`\"\n            raise TypeError(msg)\n\n    def replace(\n        self: Self,\n        *,\n        year: int | None = None,\n        week: int | None = None,\n    ) -&gt; Self:\n        \"\"\"Replaces the year and/or week of the `IsoWeek` object.\n\n        Arguments:\n            year: Year to replace. If `None`, it will not be replaced.\n            week: Week to replace. If `None`, it will not be replaced.\n\n        Returns:\n            New `IsoWeek` object with the replaced values.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeek\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; isoweek = IsoWeek(\"2025-W01\")\n            &gt;&gt;&gt; isoweek.replace(year=2022)\n            IsoWeek(2022-W01) with offset 0:00:00\n            &gt;&gt;&gt; isoweek.replace(week=2)\n            IsoWeek(2025-W02) with offset 0:00:00\n            &gt;&gt;&gt; isoweek.replace(year=2022, week=2)\n            IsoWeek(2022-W02) with offset 0:00:00\n        \"\"\"\n        # Validation of year and week is done in the constructor of the `IsoWeek` class,\n        # so we can safely use them here without additional checks.\n        return self.from_values(\n            year=year if year is not None else self.year,\n            week=week if week is not None else self.week,\n        )\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.days","title":"days  <code>property</code>","text":"<pre><code>days: tuple[date, ...]\n</code></pre> <p>Returns tuple of days (as date) in the ISO week.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; days = IsoWeek(\"2025-W01\").days\n&gt;&gt;&gt; [str(d) for d in days]\n['2024-12-30', '2024-12-31', '2025-01-01', '2025-01-02', '2025-01-03', '2025-01-04', '2025-01-05']\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: int\n</code></pre> <p>Returns quarter number as integer.</p> <p>The first three quarters have 13 weeks, while the last one has either 13 or 14 weeks depending on the year:</p> <ul> <li>Q1: weeks from 1 to 13</li> <li>Q2: weeks from 14 to 26</li> <li>Q3: weeks from 27 to 39</li> <li>Q4: weeks from 40 to 52 (or 53 if applicable)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").quarter\n1\n&gt;&gt;&gt; IsoWeek(\"2025-W32\").quarter\n3\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.week","title":"week  <code>property</code>","text":"<pre><code>week: int\n</code></pre> <p>Returns week number as integer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").week\n1\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.year","title":"year  <code>property</code>","text":"<pre><code>year: int\n</code></pre> <p>Returns year number as integer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").year\n2025\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__add__","title":"__add__","text":"<pre><code>__add__(other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]\n</code></pre> <p>Addition operation.</p> <p>It supports addition with the following types:</p> <ul> <li><code>int</code>: interpreted as number of weeks to be added to the <code>IsoWeek</code> value.</li> <li><code>Iterable</code> of <code>int</code> : adds each element of the iterable to the <code>IsoWeek</code> value and returns     a generator of <code>IsoWeek</code> objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Iterable[int]</code> <p>Object to add to <code>IsoWeek</code>.</p> required <p>Returns:</p> Type Description <code>Self | Generator[Self, None, None]</code> <p>New <code>IsoWeek</code> or generator of <code>IsoWeek</code> object(s) with the result of the addition.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code> or <code>Iterable</code> of <code>int</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeek(\"2025-W01\") + 1)\n'2025-W02'\n&gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\") + (1, 2, 3))\n('2025-W02', '2025-W03', '2025-W04')\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __add__(\n    self: Self,\n    other: int | Iterable[int],\n) -&gt; Self | Generator[Self, None, None]:\n    \"\"\"Addition operation.\n\n    It supports addition with the following types:\n\n    - `int`: interpreted as number of weeks to be added to the `IsoWeek` value.\n    - `Iterable` of `int` : adds each element of the iterable to the `IsoWeek` value and returns\n        a generator of `IsoWeek` objects.\n\n    Arguments:\n        other: Object to add to `IsoWeek`.\n\n    Returns:\n        New `IsoWeek` or generator of `IsoWeek` object(s) with the result of the addition.\n\n    Raises:\n        TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeek(\"2025-W01\") + 1)\n        '2025-W02'\n        &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\") + (1, 2, 3))\n        ('2025-W02', '2025-W03', '2025-W04')\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() + timedelta(weeks=other))\n    elif isinstance(other, Iterable) and all(isinstance(_other, int) for _other in other):\n        return (self + _other for _other in other)\n    else:\n        msg = f\"Cannot add type {type(other)} to `IsoWeek`. Addition is supported with `int` type\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__contains__","title":"__contains__","text":"<pre><code>__contains__(other: Any) -&gt; bool\n</code></pre> <p>Checks if self contains <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p><code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self week contains other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not <code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; date(2025, 1, 2) in IsoWeek(\"2025-W01\")\nTrue\n&gt;&gt;&gt; date(2025, 1, 7) in IsoWeek(\"2025-W01\")\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __contains__(self: Self, other: Any) -&gt; bool:  # noqa: ANN401\n    \"\"\"Checks if self contains `other`.\n\n    Arguments:\n        other: `IsoWeek`, `date`, `datetime` or `str`.\n\n    Returns:\n        `True` if self week contains other, `False` otherwise.\n\n    Raises:\n        TypeError: If other is not `IsoWeek`, `date`, `datetime` or `str`.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; date(2025, 1, 2) in IsoWeek(\"2025-W01\")\n        True\n        &gt;&gt;&gt; date(2025, 1, 7) in IsoWeek(\"2025-W01\")\n        False\n    \"\"\"\n    if isinstance(other, (date, datetime, str, self.__class__)):\n        _other = self._cast(other)\n        return self.__eq__(_other)\n    else:\n        msg = f\"Cannot compare type `{type(other)}` with IsoWeek\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Equality operator.</p> <p>Two ISO Week objects are considered equal if and only if they have the same <code>offset_</code> and the same <code>value_</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if objects are equal, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") == IsoWeek(\"2025-W01\")\nTrue\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") == IsoWeek(\"2025-W02\")\nFalse\n&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") == CustomIsoWeek(\"2025-W01\")\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __eq__(self: Self, other: object) -&gt; bool:\n    \"\"\"Equality operator.\n\n    Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if objects are equal, `False` otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") == IsoWeek(\"2025-W01\")\n        True\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") == IsoWeek(\"2025-W02\")\n        False\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") == CustomIsoWeek(\"2025-W01\")\n        False\n    \"\"\"\n    return super().__eq__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self | object) -&gt; bool\n</code></pre> <p>Greater than or equal operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is greater than or equal to <code>other</code>, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= IsoWeek(\"2025-W02\")\nFalse\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= IsoWeek(\"2025-W01\")\nTrue\n&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= CustomIsoWeek(\"2025-W01\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= \"2025-W01\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __ge__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Greater than or equal operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n       other: Object to compare with.\n\n    Returns:\n        `True` if self is greater than or equal to `other`, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= IsoWeek(\"2025-W02\")\n        False\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= IsoWeek(\"2025-W01\")\n        True\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= CustomIsoWeek(\"2025-W01\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt;= \"2025-W01\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__ge__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self | object) -&gt; bool\n</code></pre> <p>Greater than operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is greater than other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; IsoWeek(\"2025-W02\")\nFalse\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; IsoWeek(\"2022-W52\")\nTrue\n&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; CustomIsoWeek(\"2025-W01\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; \"2025-W01\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __gt__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Greater than operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is greater than other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; IsoWeek(\"2025-W02\")\n        False\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; IsoWeek(\"2022-W52\")\n        True\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; CustomIsoWeek(\"2025-W01\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &gt; \"2025-W01\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__gt__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Returns the hash of the object.</p> <p>The hash is calculated based on the <code>value_</code> attribute and the <code>offset_</code> attribute. This allows for proper hashing and comparison of IsoWeek objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>Hash of the IsoWeek object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; hash(IsoWeek(\"2025-W01\"))\n-8273429449497533691\n</code></pre> <pre><code>&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; hash(CustomIsoWeek(\"2025-W01\"))\n179726044712929056\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __hash__(self: Self) -&gt; int:\n    \"\"\"Returns the hash of the object.\n\n    The hash is calculated based on the `value_` attribute and the `offset_` attribute.\n    This allows for proper hashing and comparison of IsoWeek objects.\n\n    Returns:\n        Hash of the IsoWeek object.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; hash(IsoWeek(\"2025-W01\"))  # doctest: +SKIP\n        -8273429449497533691\n\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; hash(CustomIsoWeek(\"2025-W01\"))  # doctest: +SKIP\n        179726044712929056\n    \"\"\"\n    return super().__hash__()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__le__","title":"__le__","text":"<pre><code>__le__(other: Self | object) -&gt; bool\n</code></pre> <p>Less than or equal operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is less than or equal to other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= IsoWeek(\"2025-W02\")\nTrue\n&gt;&gt;&gt; IsoWeek(\"2025-W02\") &lt;= IsoWeek(\"2025-W01\")\nFalse\n&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= CustomIsoWeek(\"2025-W01\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= \"2025-W01\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __le__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Less than or equal operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is less than or equal to other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= IsoWeek(\"2025-W02\")\n        True\n        &gt;&gt;&gt; IsoWeek(\"2025-W02\") &lt;= IsoWeek(\"2025-W01\")\n        False\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= CustomIsoWeek(\"2025-W01\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt;= \"2025-W01\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__le__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self | object) -&gt; bool\n</code></pre> <p>Less than operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is less than other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; IsoWeek(\"2025-W02\")\nTrue\n&gt;&gt;&gt; IsoWeek(\"2025-W02\") &lt; IsoWeek(\"2025-W01\")\nFalse\n&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; CustomIsoWeek(\"2025-W01\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; \"2025-W01\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __lt__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Less than operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is less than other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; IsoWeek(\"2025-W02\")\n        True\n        &gt;&gt;&gt; IsoWeek(\"2025-W02\") &lt; IsoWeek(\"2025-W01\")\n        False\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; CustomIsoWeek(\"2025-W01\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") &lt; \"2025-W01\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__lt__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: object) -&gt; bool\n</code></pre> <p>Inequality operator.</p> <p>Two ISO Week objects are considered equal if and only if they have the same <code>offset_</code> and the same <code>value_</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if objects are not equal, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") != IsoWeek(\"2025-W01\")\nFalse\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") != IsoWeek(\"2025-W02\")\nTrue\n&gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") != CustomIsoWeek(\"2025-W01\")\nTrue\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __ne__(self: Self, other: object) -&gt; bool:\n    \"\"\"Inequality operator.\n\n    Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if objects are _not_ equal, `False` otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") != IsoWeek(\"2025-W01\")\n        False\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") != IsoWeek(\"2025-W02\")\n        True\n        &gt;&gt;&gt; class CustomIsoWeek(IsoWeek):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") != CustomIsoWeek(\"2025-W01\")\n        True\n    \"\"\"\n    return super().__ne__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Self\n</code></pre> <p>Returns the next ISO week.</p> <p>This is equivalent to adding 1 to the current ISO week.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Next ISO week.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; next(IsoWeek(\"2025-W01\"))\nIsoWeek(2025-W02) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __next__(self: Self) -&gt; Self:\n    \"\"\"Returns the next ISO week.\n\n    This is equivalent to adding 1 to the current ISO week.\n\n    Returns:\n        Next ISO week.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; next(IsoWeek(\"2025-W01\"))\n        IsoWeek(2025-W02) with offset 0:00:00\n    \"\"\"\n    return super().__next__()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Custom representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the IsoWeek object: class name, value and offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\")\nIsoWeek(2025-W01) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __repr__(self: Self) -&gt; str:\n    \"\"\"Custom representation.\n\n    Returns:\n        String representation of the IsoWeek object: class name, value and offset.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\")\n        IsoWeek(2025-W01) with offset 0:00:00\n    \"\"\"\n    return super().__repr__()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Custom string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the IsoWeek object in the format \"YYYY-WNN\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeek(\"2025-W01\"))\n'2025-W01'\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __str__(self: Self) -&gt; str:\n    \"\"\"Custom string representation.\n\n    Returns:\n        String representation of the IsoWeek object in the format \"YYYY-WNN\".\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeek(\"2025-W01\"))\n        '2025-W01'\n    \"\"\"\n    return super().__str__()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: int | Self | Iterable[int | Self]) -&gt; int | Self | Generator[int | Self, None, None]\n</code></pre> <p>Subtraction operation.</p> <p>It supports subtraction with the following types:</p> <ul> <li><code>int</code>: interpreted as number of weeks to be subtracted to the <code>IsoWeek</code> value.</li> <li><code>IsoWeek</code>: will result in the difference between values in weeks (<code>int</code> type).</li> <li><code>Iterable</code> of <code>int</code> and/or <code>IsoWeek</code>: subtracts each element of the iterable to the <code>IsoWeek</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Self | Iterable[int | Self]</code> <p>Object to subtract to <code>IsoWeek</code>.</p> required <p>Returns:</p> Type Description <code>int | Self | Generator[int | Self, None, None]</code> <p>Results from the subtraction, can be <code>int</code>, <code>IsoWeek</code> or Generator of <code>int</code> and/or <code>IsoWeek</code> depending on the type of <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>IsoWeek</code> or <code>Iterable</code> of those types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeek(\"2025-W01\") - 1)\n'2024-W52'\n&gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\") - (1, 2, 3))\n('2024-W52', '2024-W51', '2024-W50')\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") - IsoWeek(\"2024-W52\")\n1\n&gt;&gt;&gt; IsoWeek(\"2025-W01\") - IsoWeek(\"2024-W51\")\n2\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def __sub__(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self: Self,\n    other: int | Self | Iterable[int | Self],\n) -&gt; int | Self | Generator[int | Self, None, None]:\n    \"\"\"Subtraction operation.\n\n    It supports subtraction with the following types:\n\n    - `int`: interpreted as number of weeks to be subtracted to the `IsoWeek` value.\n    - `IsoWeek`: will result in the difference between values in weeks (`int` type).\n    - `Iterable` of `int` and/or `IsoWeek`: subtracts each element of the iterable to the `IsoWeek`.\n\n    Arguments:\n        other: Object to subtract to `IsoWeek`.\n\n    Returns:\n        Results from the subtraction, can be `int`, `IsoWeek` or Generator of `int` and/or `IsoWeek` depending\n            on the type of `other`.\n\n    Raises:\n        TypeError: If `other` is not `int`, `IsoWeek` or `Iterable` of those types.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeek(\"2025-W01\") - 1)\n        '2024-W52'\n        &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\") - (1, 2, 3))\n        ('2024-W52', '2024-W51', '2024-W50')\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") - IsoWeek(\"2024-W52\")\n        1\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\") - IsoWeek(\"2024-W51\")\n        2\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() - timedelta(weeks=other))\n    elif isinstance(other, IsoWeek) and self.offset_ == other.offset_:\n        return (self.to_date() - other.to_date()).days // 7\n    elif isinstance(other, Iterable) and all(isinstance(_other, (int, IsoWeek)) for _other in other):\n        return (self - _other for _other in other)\n    else:\n        msg = (\n            f\"Cannot subtract type {type(other)} to `IsoWeek`. \"\n            \"Subtraction is supported with `int` and `IsoWeek` types\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.add","title":"add","text":"<pre><code>add(other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]\n</code></pre> <p>Method equivalent of addition operator <code>self + other</code>.</p> <p>It supports addition with the following types:</p> <ul> <li><code>int</code>: interpreted as number of weeks to be added to the <code>IsoWeek</code> value.</li> <li><code>Iterable</code> of <code>int</code> : adds each element of the iterable to the <code>IsoWeek</code> value and returns     a generator of <code>IsoWeek</code> objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Iterable[int]</code> <p>Object to add to <code>IsoWeek</code>.</p> required <p>Returns:</p> Type Description <code>Self | Generator[Self, None, None]</code> <p>New <code>IsoWeek</code> or generator of <code>IsoWeek</code> object(s) with the result of the addition.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code> or <code>Iterable</code> of <code>int</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeek(\"2025-W01\").add(1))\n'2025-W02'\n&gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\").add((1, 2, 3)))\n('2025-W02', '2025-W03', '2025-W04')\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def add(self: Self, other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]:\n    \"\"\"Method equivalent of addition operator `self + other`.\n\n    It supports addition with the following types:\n\n    - `int`: interpreted as number of weeks to be added to the `IsoWeek` value.\n    - `Iterable` of `int` : adds each element of the iterable to the `IsoWeek` value and returns\n        a generator of `IsoWeek` objects.\n\n    Arguments:\n        other: Object to add to `IsoWeek`.\n\n    Returns:\n        New `IsoWeek` or generator of `IsoWeek` object(s) with the result of the addition.\n\n    Raises:\n        TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeek(\"2025-W01\").add(1))\n        '2025-W02'\n        &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\").add((1, 2, 3)))\n        ('2025-W02', '2025-W03', '2025-W04')\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.contains","title":"contains","text":"<pre><code>contains(other: date | datetime | str | Self | Sequence[date | datetime | str | Self]) -&gt; bool | tuple[bool, ...]\n</code></pre> <p>Checks if self contains <code>other</code>. <code>other</code> can be a single value or an iterable of values.</p> <p>In case of an iterable, the method returns a tuple of boolean values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>date | datetime | str | Self | Sequence[date | datetime | str | Self]</code> <p><code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>, or an iterable of those types.</p> required <p>Returns:</p> Type Description <code>bool | tuple[bool, ...]</code> <p>Boolean or iterable of booleans, where each boolean indicates whether self contains the corresponding value in the iterable.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not IsoWeek, date, datetime or str, or an iterable of those types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").contains([date(2025, 1, 1), date(2025, 1, 6)])\n(True, False)\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def contains(\n    self: Self, other: date | datetime | str | Self | Sequence[date | datetime | str | Self]\n) -&gt; bool | tuple[bool, ...]:\n    \"\"\"Checks if self contains `other`. `other` can be a single value or an iterable of values.\n\n    In case of an iterable, the method returns a tuple of boolean values.\n\n    Arguments:\n        other: `IsoWeek`, `date`, `datetime` or `str`, or an iterable of those types.\n\n    Returns:\n        Boolean or iterable of booleans, where each boolean indicates whether self contains the corresponding value\n            in the iterable.\n\n    Raises:\n        TypeError: If other is not IsoWeek, date, datetime or str, or an iterable of those types.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").contains([date(2025, 1, 1), date(2025, 1, 6)])\n        (True, False)\n    \"\"\"\n    if isinstance(other, (date, datetime, str, IsoWeek)):\n        return other in self\n    elif isinstance(other, Iterable):\n        return tuple(_other in self for _other in other)\n    else:\n        msg = f\"Cannot compare type `{type(other)}` with `IsoWeek`\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.from_compact","title":"from_compact  <code>classmethod</code>","text":"<pre><code>from_compact(_str: str) -&gt; Self\n</code></pre> <p>Create an IsoWeek instance from a compact string in YYYYNN format.</p> <p>Parameters:</p> Name Type Description Default <code>_str</code> <code>str</code> <p>String in YYYYNN format.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeek instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_str</code> is not a string.</p> <code>ValueError</code> <p>If <code>_str</code> does not match the expected format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek.from_compact(\"2025W01\")\nIsoWeek(2025-W01) with offset 0:00:00\n&gt;&gt;&gt; IsoWeek.from_compact(\"2025W53\")\nTraceback (most recent call last):\nValueError: Invalid week number. Year 2025 has only 52 weeks.\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef from_compact(cls: type[Self], _str: str, /) -&gt; Self:\n    \"\"\"Create an IsoWeek instance from a compact string in YYYYNN format.\n\n    Arguments:\n        _str: String in YYYYNN format.\n\n    Returns:\n        IsoWeek instance.\n\n    Raises:\n        TypeError: If `_str` is not a string.\n        ValueError: If `_str` does not match the expected format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek.from_compact(\"2025W01\")\n        IsoWeek(2025-W01) with offset 0:00:00\n        &gt;&gt;&gt; IsoWeek.from_compact(\"2025W53\")\n        Traceback (most recent call last):\n        ValueError: Invalid week number. Year 2025 has only 52 weeks.\n    \"\"\"\n    return super().from_compact(_str)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.from_date","title":"from_date  <code>classmethod</code>","text":"<pre><code>from_date(_date: date) -&gt; Self\n</code></pre> <p>Create an IsoWeek instance from a date object.</p> <p>Parameters:</p> Name Type Description Default <code>_date</code> <code>date</code> <p>Date object.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeek instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_date</code> is not a date object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek.from_date(date(2024, 12, 30))\nIsoWeek(2025-W01) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef from_date(cls: type[Self], _date: date, /) -&gt; Self:\n    \"\"\"Create an IsoWeek instance from a date object.\n\n    Arguments:\n        _date: Date object.\n\n    Returns:\n        IsoWeek instance.\n\n    Raises:\n        TypeError: If `_date` is not a date object.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek.from_date(date(2024, 12, 30))\n        IsoWeek(2025-W01) with offset 0:00:00\n    \"\"\"\n    return super().from_date(_date)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.from_datetime","title":"from_datetime  <code>classmethod</code>","text":"<pre><code>from_datetime(_datetime: datetime) -&gt; Self\n</code></pre> <p>Create an IsoWeek instance from a datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>_datetime</code> <code>datetime</code> <p>Datetime object.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeek instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_datetime</code> is not a datetime object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek.from_datetime(datetime(2024, 12, 30))\nIsoWeek(2025-W01) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef from_datetime(cls: type[Self], _datetime: datetime, /) -&gt; Self:\n    \"\"\"Create an IsoWeek instance from a datetime object.\n\n    Arguments:\n        _datetime: Datetime object.\n\n    Returns:\n        IsoWeek instance.\n\n    Raises:\n        TypeError: If `_datetime` is not a datetime object.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek.from_datetime(datetime(2024, 12, 30))\n        IsoWeek(2025-W01) with offset 0:00:00\n    \"\"\"\n    return super().from_datetime(_datetime)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(_str: str) -&gt; Self\n</code></pre> <p>Create an IsoWeek instance from a string in YYYY-WNN format.</p> <p>Parameters:</p> Name Type Description Default <code>_str</code> <code>str</code> <p>String in YYYY-WNN format.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeek instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_str</code> is not a string.</p> <code>ValueError</code> <p>If <code>_str</code> does not match the expected format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek.from_string(\"2025-W01\")\nIsoWeek(2025-W01) with offset 0:00:00\n&gt;&gt;&gt; IsoWeek.from_string(\"2025-W53\")\nTraceback (most recent call last):\nValueError: Invalid week number. Year 2025 has only 52 weeks.\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef from_string(cls: type[Self], _str: str, /) -&gt; Self:\n    \"\"\"Create an IsoWeek instance from a string in YYYY-WNN format.\n\n    Arguments:\n        _str: String in YYYY-WNN format.\n\n    Returns:\n        IsoWeek instance.\n\n    Raises:\n        TypeError: If `_str` is not a string.\n        ValueError: If `_str` does not match the expected format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek.from_string(\"2025-W01\")\n        IsoWeek(2025-W01) with offset 0:00:00\n        &gt;&gt;&gt; IsoWeek.from_string(\"2025-W53\")\n        Traceback (most recent call last):\n        ValueError: Invalid week number. Year 2025 has only 52 weeks.\n    \"\"\"\n    return super().from_string(_str)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.from_today","title":"from_today  <code>classmethod</code>","text":"<pre><code>from_today(time_zone: tzinfo | None = None) -&gt; Self\n</code></pre> <p>Create an IsoWeek instance from the current date.</p> <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeek instance representing the current date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek.from_today() == IsoWeek.from_date(datetime.now().date())\nTrue\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef from_today(cls: type[Self], time_zone: tzinfo | None = None) -&gt; Self:\n    \"\"\"Create an IsoWeek instance from the current date.\n\n    Returns:\n        IsoWeek instance representing the current date.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek.from_today() == IsoWeek.from_date(datetime.now().date())\n        True\n    \"\"\"\n    return cls.from_datetime(datetime.now(tz=time_zone))\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.from_values","title":"from_values  <code>classmethod</code>","text":"<pre><code>from_values(year: int, week: int) -&gt; Self\n</code></pre> <p>Create an IsoWeek instance from year and week number.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year number (YYYY).</p> required <code>week</code> <code>int</code> <p>Week number (NN).</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeek instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek.from_values(2025, 1)\nIsoWeek(2025-W01) with offset 0:00:00\n&gt;&gt;&gt; IsoWeek.from_values(2025, 53)\nTraceback (most recent call last):\nValueError: Invalid week number. Year 2025 has only 52 weeks.\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef from_values(cls: type[Self], year: int, week: int) -&gt; Self:\n    \"\"\"Create an IsoWeek instance from year and week number.\n\n    Arguments:\n        year: Year number (YYYY).\n        week: Week number (NN).\n\n    Returns:\n        IsoWeek instance.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek.from_values(2025, 1)\n        IsoWeek(2025-W01) with offset 0:00:00\n        &gt;&gt;&gt; IsoWeek.from_values(2025, 53)\n        Traceback (most recent call last):\n        ValueError: Invalid week number. Year 2025 has only 52 weeks.\n    \"\"\"\n    value = cls._format.replace(\"YYYY\", str(year).zfill(4)).replace(\"NN\", str(week).zfill(2))\n    return cls(value)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.is_after","title":"is_after","text":"<pre><code>is_after(other: Self | object) -&gt; bool\n</code></pre> <p>Checks if <code>self</code> is after <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>self</code> is after <code>other</code>, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").is_after(IsoWeek(\"2024-W52\"))\nTrue\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").is_after(IsoWeek(\"2025-W01\"))\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def is_after(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Checks if `self` is after `other`.\n\n    Arguments:\n        other: Other object to compare with.\n\n    Returns:\n        True if `self` is after `other`, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_after(IsoWeek(\"2024-W52\"))\n        True\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_after(IsoWeek(\"2025-W01\"))\n        False\n    \"\"\"\n    return super().is_after(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.is_before","title":"is_before","text":"<pre><code>is_before(other: Self | object) -&gt; bool\n</code></pre> <p>Checks if <code>self</code> is before <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>self</code> is before <code>other</code>, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").is_before(IsoWeek(\"2025-W02\"))\nTrue\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").is_before(IsoWeek(\"2025-W01\"))\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def is_before(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Checks if `self` is before `other`.\n\n    Arguments:\n        other: Other object to compare with.\n\n    Returns:\n        True if `self` is before `other`, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_before(IsoWeek(\"2025-W02\"))\n        True\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_before(IsoWeek(\"2025-W01\"))\n        False\n    \"\"\"\n    return super().is_before(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.is_between","title":"is_between","text":"<pre><code>is_between(lower_bound: Self, upper_bound: Self, inclusive: Literal['both', 'left', 'right', 'neither'] = 'both') -&gt; bool\n</code></pre> <p>Check if <code>self</code> is between <code>lower_bound</code> and <code>upper_bound</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Self</code> <p>Lower bound to compare with.</p> required <code>upper_bound</code> <code>Self</code> <p>Upper bound to compare with.</p> required <code>inclusive</code> <code>Literal['both', 'left', 'right', 'neither']</code> <p>Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".</p> <code>'both'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>self</code> is between <code>lower_bound</code> and <code>upper_bound</code>, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").is_between(IsoWeek(\"2024-W52\"), IsoWeek(\"2025-W02\"))\nTrue\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").is_between(IsoWeek(\"2025-W01\"), IsoWeek(\"2025-W02\"), inclusive=\"neither\")\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def is_between(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self: Self,\n    lower_bound: Self,\n    upper_bound: Self,\n    inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n) -&gt; bool:\n    \"\"\"Check if `self` is between `lower_bound` and `upper_bound`.\n\n    Arguments:\n        lower_bound: Lower bound to compare with.\n        upper_bound: Upper bound to compare with.\n        inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n\n    Returns:\n        True if `self` is between `lower_bound` and `upper_bound`, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_between(IsoWeek(\"2024-W52\"), IsoWeek(\"2025-W02\"))\n        True\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").is_between(IsoWeek(\"2025-W01\"), IsoWeek(\"2025-W02\"), inclusive=\"neither\")\n        False\n    \"\"\"\n    return super().is_between(lower_bound=lower_bound, upper_bound=upper_bound, inclusive=inclusive)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.next","title":"next","text":"<pre><code>next() -&gt; Self\n</code></pre> <p>Method equivalent of adding 1 to the current value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Next <code>IsoWeek</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").next()\nIsoWeek(2025-W02) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def next(self: Self) -&gt; Self:\n    \"\"\"Method equivalent of adding 1 to the current value.\n\n    Returns:\n        Next `IsoWeek` object.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").next()\n        IsoWeek(2025-W02) with offset 0:00:00\n    \"\"\"\n    return super().next()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.nth","title":"nth","text":"<pre><code>nth(n: int) -&gt; date\n</code></pre> <p>Returns the n-th day of the week using the ISO weekday numbering convention (1=first, .. , 7=Last day).</p> <p>Info</p> <p>Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Day number between 1 and 7.</p> required <p>Returns:</p> Type Description <code>date</code> <p><code>date</code> object representing the Nth day of the week.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>n</code> is not an integer.</p> <code>ValueError</code> <p>If <code>n</code> is not between 1 and 7.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").nth(1)\ndatetime.date(2024, 12, 30)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").nth(7)\ndatetime.date(2025, 1, 5)\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def nth(self: Self, n: int) -&gt; date:\n    \"\"\"Returns the n-th day of the week using the ISO weekday numbering convention (1=first, .. , 7=Last day).\n\n    !!! info\n        Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n    Arguments:\n        n: Day number between 1 and 7.\n\n    Returns:\n        `date` object representing the Nth day of the week.\n\n    Raises:\n        TypeError: If `n` is not an integer.\n        ValueError: If `n` is not between 1 and 7.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").nth(1)\n        datetime.date(2024, 12, 30)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").nth(7)\n        datetime.date(2025, 1, 5)\n    \"\"\"\n    if not isinstance(n, int):\n        msg = f\"`n` must be an integer, found {type(n)}\"\n        raise TypeError(msg)\n    if n not in range(1, 8):\n        msg = f\"`n` must be between 1 and 7, found {n}\"\n        raise ValueError(msg)\n\n    return self.days[n - 1]\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.previous","title":"previous","text":"<pre><code>previous() -&gt; Self\n</code></pre> <p>Method equivalent of subtracting 1 to the current value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Previous <code>IsoWeek</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").previous()\nIsoWeek(2024-W52) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def previous(self: Self) -&gt; Self:\n    \"\"\"Method equivalent of subtracting 1 to the current value.\n\n    Returns:\n        Previous `IsoWeek` object.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").previous()\n        IsoWeek(2024-W52) with offset 0:00:00\n    \"\"\"\n    return super().previous()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.range","title":"range  <code>classmethod</code>","text":"<pre><code>range(start: date | datetime | str | Self, end: date | datetime | str | Self, *, step: int = 1, inclusive: Literal['both', 'left', 'right', 'neither'] = 'both', as_str: bool = True) -&gt; Generator[str | Self, None, None]\n</code></pre> <p>Generates <code>IsoWeek</code> (or <code>str</code>) between <code>start</code> and <code>end</code> values with given <code>step</code>.</p> <p><code>inclusive</code> parameter can be used to control inclusion of <code>start</code> and/or <code>end</code> week values.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return str values, otherwise it will return <code>BaseIsoWeek</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>date | datetime | str | Self</code> <p>Starting value. It can be <code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <code>end</code> <code>date | datetime | str | Self</code> <p>Ending value. It can be <code>IsoWeek</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <code>step</code> <code>int</code> <p>Step between generated values, must be positive integer.</p> <code>1</code> <code>inclusive</code> <code>Literal['both', 'left', 'right', 'neither']</code> <p>Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".</p> <code>'both'</code> <code>as_str</code> <code>bool</code> <p>Whether to return <code>str</code> or <code>IsoWeek</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>Generator of <code>IsoWeek</code> or <code>str</code> between <code>start</code> and <code>end</code> values with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the following conditions is met:</p> <ul> <li><code>start &gt; end</code>.</li> <li><code>inclusive</code> not one of \"both\", \"left\", \"right\" or \"neither\".</li> <li><code>step</code> is not strictly positive.</li> </ul> <code>TypeError</code> <p>If <code>step</code> is not an int.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; tuple(\n...     IsoWeek.range(\n...         start=\"2025-W01\",\n...         end=\"2025-W07\",\n...         step=2,\n...         inclusive=\"both\",\n...         as_str=True,\n...     )\n... )\n('2025-W01', '2025-W03', '2025-W05', '2025-W07')\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>@classmethod\ndef range(  # pyright: ignore[reportIncompatibleMethodOverride]\n    cls: type[Self],\n    start: date | datetime | str | Self,\n    end: date | datetime | str | Self,\n    *,\n    step: int = 1,\n    inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n    as_str: bool = True,\n) -&gt; Generator[str | Self, None, None]:\n    \"\"\"Generates `IsoWeek` (or `str`) between `start` and `end` values with given `step`.\n\n    `inclusive` parameter can be used to control inclusion of `start` and/or `end` week values.\n\n    If `as_str` is flagged as `True`, it will return str values, otherwise it will return `BaseIsoWeek` objects.\n\n    Arguments:\n        start: Starting value. It can be `IsoWeek`, `date`, `datetime` or `str`.\n        end: Ending value. It can be `IsoWeek`, `date`, `datetime` or `str`.\n        step: Step between generated values, must be positive integer.\n        inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n        as_str: Whether to return `str` or `IsoWeek` object.\n\n    Returns:\n        Generator of `IsoWeek` or `str` between `start` and `end` values with given `step`.\n\n    Raises:\n        ValueError: If any of the following conditions is met:\n\n            - `start &gt; end`.\n            - `inclusive` not one of \"both\", \"left\", \"right\" or \"neither\".\n            - `step` is not strictly positive.\n        TypeError: If `step` is not an int.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; tuple(\n        ...     IsoWeek.range(\n        ...         start=\"2025-W01\",\n        ...         end=\"2025-W07\",\n        ...         step=2,\n        ...         inclusive=\"both\",\n        ...         as_str=True,\n        ...     )\n        ... )\n        ('2025-W01', '2025-W03', '2025-W05', '2025-W07')\n    \"\"\"\n    return super().range(\n        start=start,\n        end=end,\n        step=step,\n        inclusive=inclusive,\n        as_str=as_str,\n    )\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.replace","title":"replace","text":"<pre><code>replace(*, year: int | None = None, week: int | None = None) -&gt; Self\n</code></pre> <p>Replaces the year and/or week of the <code>IsoWeek</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int | None</code> <p>Year to replace. If <code>None</code>, it will not be replaced.</p> <code>None</code> <code>week</code> <code>int | None</code> <p>Week to replace. If <code>None</code>, it will not be replaced.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>New <code>IsoWeek</code> object with the replaced values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; isoweek = IsoWeek(\"2025-W01\")\n&gt;&gt;&gt; isoweek.replace(year=2022)\nIsoWeek(2022-W01) with offset 0:00:00\n&gt;&gt;&gt; isoweek.replace(week=2)\nIsoWeek(2025-W02) with offset 0:00:00\n&gt;&gt;&gt; isoweek.replace(year=2022, week=2)\nIsoWeek(2022-W02) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def replace(\n    self: Self,\n    *,\n    year: int | None = None,\n    week: int | None = None,\n) -&gt; Self:\n    \"\"\"Replaces the year and/or week of the `IsoWeek` object.\n\n    Arguments:\n        year: Year to replace. If `None`, it will not be replaced.\n        week: Week to replace. If `None`, it will not be replaced.\n\n    Returns:\n        New `IsoWeek` object with the replaced values.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; isoweek = IsoWeek(\"2025-W01\")\n        &gt;&gt;&gt; isoweek.replace(year=2022)\n        IsoWeek(2022-W01) with offset 0:00:00\n        &gt;&gt;&gt; isoweek.replace(week=2)\n        IsoWeek(2025-W02) with offset 0:00:00\n        &gt;&gt;&gt; isoweek.replace(year=2022, week=2)\n        IsoWeek(2022-W02) with offset 0:00:00\n    \"\"\"\n    # Validation of year and week is done in the constructor of the `IsoWeek` class,\n    # so we can safely use them here without additional checks.\n    return self.from_values(\n        year=year if year is not None else self.year,\n        week=week if week is not None else self.week,\n    )\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.sub","title":"sub","text":"<pre><code>sub(other: int | Self | Iterable[int | Self]) -&gt; int | Self | Generator[int | Self, None, None]\n</code></pre> <p>Method equivalent of subtraction operator <code>self - other</code>.</p> <p>It supports subtraction with the following types:</p> <ul> <li><code>int</code>: interpreted as number of weeks to be subtracted to the <code>IsoWeek</code> value.</li> <li><code>IsoWeek</code>: will result in the difference between values in weeks (<code>int</code> type).</li> <li><code>Iterable</code> of <code>int</code> and/or <code>IsoWeek</code>: subtracts each element of the iterable to the <code>IsoWeek</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Self | Iterable[int | Self]</code> <p>Object to subtract to <code>IsoWeek</code>.</p> required <p>Returns:</p> Type Description <code>int | Self | Generator[int | Self, None, None]</code> <p>Results from the subtraction, can be <code>int</code>, <code>IsoWeek</code> or Generator of <code>int</code> and/or <code>IsoWeek</code> depending on the type of <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>IsoWeek</code> or <code>Iterable</code> of those types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeek(\"2025-W01\").sub(1))\n'2024-W52'\n&gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\").sub((1, 2, 3)))\n('2024-W52', '2024-W51', '2024-W50')\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").sub(IsoWeek(\"2024-W52\"))\n1\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").sub(IsoWeek(\"2024-W51\"))\n2\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def sub(\n    self: Self,\n    other: int | Self | Iterable[int | Self],\n) -&gt; int | Self | Generator[int | Self, None, None]:\n    \"\"\"Method equivalent of subtraction operator `self - other`.\n\n    It supports subtraction with the following types:\n\n    - `int`: interpreted as number of weeks to be subtracted to the `IsoWeek` value.\n    - `IsoWeek`: will result in the difference between values in weeks (`int` type).\n    - `Iterable` of `int` and/or `IsoWeek`: subtracts each element of the iterable to the `IsoWeek`.\n\n    Arguments:\n        other: Object to subtract to `IsoWeek`.\n\n    Returns:\n        Results from the subtraction, can be `int`, `IsoWeek` or Generator of `int` and/or `IsoWeek` depending\n            on the type of `other`.\n\n    Raises:\n        TypeError: If `other` is not `int`, `IsoWeek` or `Iterable` of those types.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeek(\"2025-W01\").sub(1))\n        '2024-W52'\n        &gt;&gt;&gt; tuple(str(iw) for iw in IsoWeek(\"2025-W01\").sub((1, 2, 3)))\n        ('2024-W52', '2024-W51', '2024-W50')\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").sub(IsoWeek(\"2024-W52\"))\n        1\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").sub(IsoWeek(\"2024-W51\"))\n        2\n    \"\"\"\n    return self.__sub__(other)\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_compact","title":"to_compact","text":"<pre><code>to_compact() -&gt; str\n</code></pre> <p>Returns as a string in the YYYYWNN format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_compact()\n'2025W01'\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_compact(self: Self) -&gt; str:\n    \"\"\"Returns as a string in the YYYYWNN format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_compact()\n        '2025W01'\n    \"\"\"\n    return super().to_compact()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_date","title":"to_date","text":"<pre><code>to_date(weekday: int = 1) -&gt; date\n</code></pre> <p>Converts <code>IsoWeek</code> to <code>date</code> object with the given <code>weekday</code>.</p> <p>If no weekday is provided then the first day of the week is used.</p> <p>Info</p> <p>Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.</p> <p>Parameters:</p> Name Type Description Default <code>weekday</code> <code>int</code> <p>Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7 is the last day of the week.</p> <code>1</code> <p>Returns:</p> Type Description <code>date</code> <p><code>IsoWeek</code> value in <code>date</code> type with the given weekday.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>weekday</code> is not an integer.</p> <code>ValueError</code> <p>If <code>weekday</code> is not between 1 and 7.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_date()\ndatetime.date(2024, 12, 30)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_date(3)\ndatetime.date(2025, 1, 1)\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_date(self: Self, weekday: int = 1) -&gt; date:\n    \"\"\"Converts `IsoWeek` to `date` object with the given `weekday`.\n\n    If no weekday is provided then the first day of the week is used.\n\n    !!! info\n        Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n    Arguments:\n        weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n            is the last day of the week.\n\n    Returns:\n        `IsoWeek` value in `date` type with the given weekday.\n\n    Raises:\n        TypeError: If `weekday` is not an integer.\n        ValueError: If `weekday` is not between 1 and 7.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_date()\n        datetime.date(2024, 12, 30)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_date(3)\n        datetime.date(2025, 1, 1)\n    \"\"\"\n    return self.to_datetime(weekday).date()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(weekday: int = 1) -&gt; datetime\n</code></pre> <p>Converts <code>IsoWeek</code> to <code>datetime</code> object with the given weekday.</p> <p>If no weekday is provided then the first day of the week is used.</p> <p>Info</p> <p>Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.</p> <p>Parameters:</p> Name Type Description Default <code>weekday</code> <code>int</code> <p>Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7 is the last day of the week.</p> <code>1</code> <p>Returns:</p> Type Description <code>datetime</code> <p><code>IsoWeek</code> value in <code>datetime</code> type with the given weekday.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>weekday</code> is not an integer.</p> <code>ValueError</code> <p>If <code>weekday</code> is not between 1 and 7.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_datetime()\ndatetime.datetime(2024, 12, 30, 0, 0)\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_datetime(3)\ndatetime.datetime(2025, 1, 1, 0, 0)\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_datetime(self: Self, weekday: int = 1) -&gt; datetime:\n    \"\"\"Converts `IsoWeek` to `datetime` object with the given weekday.\n\n    If no weekday is provided then the first day of the week is used.\n\n    !!! info\n        Weekday is not the same as the day of the week. The weekday is an integer between 1 and 7.\n\n    Arguments:\n        weekday: Weekday to use. It must be an integer between 1 and 7, where 1 is the first day of the week and 7\n            is the last day of the week.\n\n    Returns:\n        `IsoWeek` value in `datetime` type with the given weekday.\n\n    Raises:\n        TypeError: If `weekday` is not an integer.\n        ValueError: If `weekday` is not between 1 and 7.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_datetime()\n        datetime.datetime(2024, 12, 30, 0, 0)\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_datetime(3)\n        datetime.datetime(2025, 1, 1, 0, 0)\n    \"\"\"\n    if not isinstance(weekday, int):\n        msg = f\"`weekday` must be an integer between 1 and 7, found {type(weekday)}\"\n        raise TypeError(msg)\n    if weekday not in range(1, 8):\n        msg = f\"Invalid `weekday`. Weekday must be between 1 and 7, found {weekday}\"\n        raise ValueError(msg)\n\n    return super()._to_datetime(f\"{self.value_}-{weekday}\")\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Returns as a string in the YYYY-WNN format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_string()\n'2025-W01'\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_string(self: Self) -&gt; str:\n    \"\"\"Returns as a string in the YYYY-WNN format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_string()\n        '2025-W01'\n    \"\"\"\n    return super().to_string()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.to_values","title":"to_values","text":"<pre><code>to_values() -&gt; tuple[int, ...]\n</code></pre> <p>Returns the year and week as a tuple of integers.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>Tuple of integers representing the year and week.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeek(\"2025-W01\").to_values()\n(2025, 1)\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def to_values(self: Self) -&gt; tuple[int, ...]:\n    \"\"\"Returns the year and week as a tuple of integers.\n\n    Returns:\n        Tuple of integers representing the year and week.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeek(\"2025-W01\").to_values()\n        (2025, 1)\n    \"\"\"\n    return super().to_values()\n</code></pre>"},{"location":"api/isoweek/#iso_week_date.isoweek.IsoWeek.weeksout","title":"weeksout","text":"<pre><code>weeksout(n_weeks: int, *, step: int = 1, as_str: bool = True) -&gt; Generator[str | IsoWeek, None, None]\n</code></pre> <p>Generate range of <code>IsoWeek</code> (or <code>str</code>) from one to <code>n_weeks</code> ahead of current <code>value</code>, with given <code>step</code>.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return <code>str</code> values, otherwise it will return <code>IsoWeek</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>n_weeks</code> <code>int</code> <p>Number of weeks to be generated from current value.</p> required <code>step</code> <code>int</code> <p>Step between weeks, must be positive integer.</p> <code>1</code> <code>as_str</code> <code>bool</code> <p>Whether to return str or IsoWeek object.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>Generator of <code>IsoWeek</code>s (or <code>str</code>s) from one week to <code>n_weeks</code> ahead of current <code>value</code> with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>n_weeks</code> and/or <code>step</code> is not int.</p> <code>ValueError</code> <p>If <code>n_weeks</code> and/or <code>step</code> is not strictly positive.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; isoweek = IsoWeek(\"2025-W01\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; tuple(isoweek.weeksout(4))\n('2025-W02', '2025-W03', '2025-W04', '2025-W05')\n&gt;&gt;&gt; tuple(isoweek.weeksout(4, step=2))\n('2025-W02', '2025-W04')\n</code></pre> Source code in <code>iso_week_date/isoweek.py</code> <pre><code>def weeksout(\n    self: Self,\n    n_weeks: int,\n    *,\n    step: int = 1,\n    as_str: bool = True,\n) -&gt; Generator[str | IsoWeek, None, None]:\n    \"\"\"Generate range of `IsoWeek` (or `str`) from one to `n_weeks` ahead of current `value`, with given `step`.\n\n    If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeek` objects.\n\n    Arguments:\n        n_weeks: Number of weeks to be generated from current value.\n        step: Step between weeks, must be positive integer.\n        as_str: Whether to return str or IsoWeek object.\n\n    Returns:\n        Generator of `IsoWeek`s (or `str`s) from one week to `n_weeks` ahead of current `value` with given `step`.\n\n    Raises:\n        TypeError: If `n_weeks` and/or `step` is not int.\n        ValueError: If `n_weeks` and/or `step` is not strictly positive.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; isoweek = IsoWeek(\"2025-W01\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; tuple(isoweek.weeksout(4))\n        ('2025-W02', '2025-W03', '2025-W04', '2025-W05')\n        &gt;&gt;&gt; tuple(isoweek.weeksout(4, step=2))\n        ('2025-W02', '2025-W04')\n    \"\"\"\n    if not isinstance(n_weeks, int):\n        msg = f\"`n_weeks` must be an integer, found {type(n_weeks)} type\"\n        raise TypeError(msg)\n\n    if n_weeks &lt;= 0:\n        msg = f\"`n_weeks` must be strictly positive, found {n_weeks}\"\n        raise ValueError(msg)\n\n    start, end = (self + 1), (self + n_weeks)\n    return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n</code></pre>"},{"location":"api/isoweekdate/","title":"<code>IsoWeekDate</code> class","text":""},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate","title":"iso_week_date.isoweekdate.IsoWeekDate","text":"<p>               Bases: <code>BaseIsoWeek</code></p> <p>Represents ISO Week date in the  \"YYYY-WNN-D\" format.</p> <p>The class implements methods and functionalities to work directly with iso week date format and avoid moving back and forth between <code>date</code>, <code>datetime</code> and <code>str</code> objects.</p> <p>Attributes:</p> Name Type Description <code>value_</code> <p>iso-week string of format \"YYYY-WNN-D\" where:</p> <ul> <li>YYYY is between 0001 and 9999</li> <li>W is a literal character</li> <li>NN is between 01 and 53</li> <li>D is between 1 and 7</li> </ul> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>class IsoWeekDate(BaseIsoWeek):\n    \"\"\"Represents [ISO Week date](https://en.wikipedia.org/wiki/ISO_week_date) in the  _\"YYYY-WNN-D\"_ format.\n\n    The class implements methods and functionalities to work directly with iso week date format and avoid moving back\n    and forth between `date`, `datetime` and `str` objects.\n\n    Attributes:\n        value_: iso-week string of format \"YYYY-WNN-D\" where:\n\n            - YYYY is between 0001 and 9999\n            - W is a literal character\n            - NN is between 01 and 53\n            - D is between 1 and 7\n    \"\"\"\n\n    # class attributes\n\n    _pattern = ISOWEEKDATE_PATTERN\n    _format = ISOWEEKDATE__FORMAT\n    _date_format = ISOWEEKDATE__DATE_FORMAT\n\n    # properties\n\n    @property\n    def year(self: Self) -&gt; int:\n        \"\"\"Returns year number as integer.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").year\n            2025\n        \"\"\"\n        return super().year\n\n    @property\n    def week(self: Self) -&gt; int:\n        \"\"\"Returns week number as integer.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").week\n            1\n        \"\"\"\n        return super().week\n\n    @property\n    def weekday(self: Self) -&gt; int:\n        \"\"\"Returns weekday number as integer.\n\n        Returns:\n            `int` with day number as integer corresponding to the `IsoWeekDate`.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").day\n            3\n        \"\"\"\n        return int(self.value_[9])\n\n    @property\n    def quarter(self: Self) -&gt; int:\n        \"\"\"Returns quarter number as integer.\n\n        The first three quarters have 13 weeks, while the last one has either 13 or 14 weeks depending on the year:\n\n        - Q1: weeks from 1 to 13\n        - Q2: weeks from 14 to 26\n        - Q3: weeks from 27 to 39\n        - Q4: weeks from 40 to 52 (or 53 if applicable)\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").quarter\n            1\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W32-4\").quarter\n            3\n        \"\"\"\n        return super().quarter\n\n    day = weekday  # Alias for backward compatibility\n    \"\"\"Alias for `weekday` property.\"\"\"\n\n    @property\n    def isoweek(self: Self) -&gt; str:\n        \"\"\"Returns iso-week string value.\n\n        Returns:\n            `str` with iso-week string value (YYYY-WNN format) corresponding to the `IsoWeekDate`.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").isoweek\n            '2025-W01'\n        \"\"\"\n        return self.value_[:8]\n\n    # dunder methods\n\n    def __eq__(self: Self, other: object) -&gt; bool:\n        \"\"\"Equality operator.\n\n        Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if objects are equal, `False` otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == IsoWeekDate(\"2025-W01-3\")\n            True\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == IsoWeekDate(\"2025-W02-1\")\n            False\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == CustomIsoWeekDate(\"2025-W01-3\")\n            False\n        \"\"\"\n        return super().__eq__(other)\n\n    def __ne__(self: Self, other: object) -&gt; bool:\n        \"\"\"Inequality operator.\n\n        Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if objects are _not_ equal, `False` otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != IsoWeekDate(\"2025-W01-3\")\n            False\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != IsoWeekDate(\"2025-W02-1\")\n            True\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != CustomIsoWeekDate(\"2025-W01-3\")\n            True\n        \"\"\"\n        return super().__ne__(other)\n\n    def __lt__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Less than operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is less than other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; IsoWeekDate(\"2025-W02-1\")\n            True\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W02-7\") &lt; IsoWeekDate(\"2025-W01-3\")\n            False\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; CustomIsoWeekDate(\"2025-W01-3\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; \"2025-W01-3\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__lt__(other)\n\n    def __le__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Less than or equal operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is less than or equal to other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= IsoWeekDate(\"2025-W02-1\")\n            True\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W02-7\") &lt;= IsoWeekDate(\"2025-W01-3\")\n            False\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= CustomIsoWeekDate(\"2025-W01-3\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= \"2025-W01-3\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__le__(other)\n\n    def __gt__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Greater than operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n            other: Object to compare with.\n\n        Returns:\n            `True` if self is greater than other, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; IsoWeekDate(\"2025-W02-1\")\n            False\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; IsoWeekDate(\"2024-W52-7\")\n            True\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; CustomIsoWeekDate(\"2025-W01-3\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; \"2025-W01-3\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__gt__(other)\n\n    def __ge__(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Greater than or equal operator.\n\n        Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n        If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n        Arguments:\n           other: Object to compare with.\n\n        Returns:\n            `True` if self is greater than or equal to `other`, `False` otherwise.\n\n        Raises:\n            TypeError: If `other` is not of same type or it has a different offset.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= IsoWeekDate(\"2025-W02-1\")\n            False\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= IsoWeekDate(\"2025-W01-2\")\n            True\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= CustomIsoWeekDate(\"2025-W01-3\")\n            Traceback (most recent call last):\n            TypeError: ...\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= \"2025-W01-3\"\n            Traceback (most recent call last):\n            TypeError: ...\n        \"\"\"\n        return super().__ge__(other)\n\n    def __hash__(self: Self) -&gt; int:\n        \"\"\"Returns the hash of the object.\n\n        The hash is calculated based on the `value_` attribute and the `offset_` attribute.\n        This allows for proper hashing and comparison of IsoWeekDate objects.\n\n        Returns:\n            Hash of the IsoWeekDate object.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; hash(IsoWeekDate(\"2025-W01-3\"))  # doctest: +SKIP\n            -7997434344089344162\n\n            &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n            ...     offset_ = timedelta(days=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; hash(CustomIsoWeekDate(\"2025-W01-3\"))  # doctest: +SKIP\n            455721150121118585\n        \"\"\"\n        return super().__hash__()\n\n    def __next__(self: Self) -&gt; Self:\n        \"\"\"Returns the next ISO week date.\n\n        This is equivalent to adding 1 to the current ISO week date.\n\n        Returns:\n            Next ISO week date.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; next(IsoWeekDate(\"2025-W01-4\"))\n            IsoWeekDate(2025-W01-5) with offset 0:00:00\n        \"\"\"\n        return super().__next__()\n\n    def __repr__(self: Self) -&gt; str:\n        \"\"\"Custom representation.\n\n        Returns:\n            String representation of the IsoWeekDate object: class name, value and offset.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\")\n            IsoWeekDate(2025-W01-1) with offset 0:00:00\n        \"\"\"\n        return super().__repr__()\n\n    def __str__(self: Self) -&gt; str:\n        \"\"\"Custom string representation.\n\n        Returns:\n            String representation of the IsoWeekDate object in the format \"YYYY-WNN-D\".\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\"))\n            '2025-W01-1'\n        \"\"\"\n        return super().__str__()\n\n    # from_* methods\n\n    @classmethod\n    def from_string(cls: type[Self], _str: str, /) -&gt; Self:\n        \"\"\"Create an IsoWeekDate instance from a string in YYYY-WNN-D format.\n\n        Arguments:\n            _str: String in YYYY-WNN-D format.\n\n        Returns:\n            IsoWeekDate instance.\n\n        Raises:\n            TypeError: If `_str` is not a string.\n            ValueError: If `_str` does not match the expected format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate.from_string(\"2025-W01-4\")\n            IsoWeekDate(2025-W01-4) with offset 0:00:00\n            &gt;&gt;&gt; IsoWeekDate.from_string(\"2025-W53-1\")\n            Traceback (most recent call last):\n            ValueError: Invalid week number. Year 2025 has only 52 weeks.\n        \"\"\"\n        return super().from_string(_str)\n\n    @classmethod\n    def from_compact(cls: type[Self], _str: str, /) -&gt; Self:\n        \"\"\"Create an IsoWeekDate instance from a compact string in YYYYNND format.\n\n        Arguments:\n            _str: String in YYYYNND format.\n\n        Returns:\n            IsoWeekDate instance.\n\n        Raises:\n            TypeError: If `_str` is not a string.\n            ValueError: If `_str` does not match the expected format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate.from_compact(\"2025W013\")\n            IsoWeekDate(2025-W01-3) with offset 0:00:00\n            &gt;&gt;&gt; IsoWeekDate.from_compact(\"2025W537\")\n            Traceback (most recent call last):\n            ValueError: Invalid week number. Year 2025 has only 52 weeks.\n        \"\"\"\n        return super().from_compact(_str)\n\n    @classmethod\n    def from_date(cls: type[Self], _date: date, /) -&gt; Self:\n        \"\"\"Create an IsoWeekDate instance from a date object.\n\n        Arguments:\n            _date: Date object.\n\n        Returns:\n            IsoWeekDate instance.\n\n        Raises:\n            TypeError: If `_date` is not a date object.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate.from_date(date(2024, 12, 31))\n            IsoWeekDate(2025-W01-2) with offset 0:00:00\n        \"\"\"\n        return super().from_date(_date)\n\n    @classmethod\n    def from_datetime(cls: type[Self], _datetime: datetime, /) -&gt; Self:\n        \"\"\"Create an IsoWeekDate instance from a datetime object.\n\n        Arguments:\n            _datetime: Datetime object.\n\n        Returns:\n            IsoWeekDate instance.\n\n        Raises:\n            TypeError: If `_datetime` is not a datetime object.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate.from_datetime(datetime(2024, 12, 31))\n            IsoWeekDate(2025-W01-2) with offset 0:00:00\n        \"\"\"\n        return super().from_datetime(_datetime)\n\n    @classmethod\n    def from_today(cls: type[Self], time_zone: tzinfo | None = None) -&gt; Self:\n        \"\"\"Create an IsoWeekDate instance from the current date.\n\n        Returns:\n            IsoWeekDate instance representing the current date.\n\n        Examples:\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate.from_today() == IsoWeekDate.from_date(datetime.now().date())\n            True\n        \"\"\"\n        return cls.from_datetime(datetime.now(tz=time_zone))\n\n    @classmethod\n    def from_values(cls: type[Self], year: int, week: int, weekday: int) -&gt; Self:\n        \"\"\"Create an IsoWeekDate instance from year and week number.\n\n        Arguments:\n            year: Year number (YYYY).\n            week: Week number (NN).\n            weekday: Weekday number (D).\n\n        Returns:\n            IsoWeekDate instance.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate.from_values(year=2025, week=1, weekday=4)\n            IsoWeekDate(2025-W01-4) with offset 0:00:00\n            &gt;&gt;&gt; IsoWeekDate.from_values(2025, 53, 1)\n            Traceback (most recent call last):\n            ValueError: Invalid week number. Year 2025 has only 52 weeks.\n        \"\"\"\n        value = (\n            cls._format.replace(\"YYYY\", str(year).zfill(4)).replace(\"NN\", str(week).zfill(2)).replace(\"D\", str(weekday))\n        )\n        return cls(value)\n\n    # to_* methods\n\n    def to_string(self: Self) -&gt; str:\n        \"\"\"Returns as a string in the YYYY-WNN-D format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_string()\n            '2025-W01-4'\n        \"\"\"\n        return super().to_string()\n\n    def to_compact(self: Self) -&gt; str:\n        \"\"\"Returns as a string in the YYYYWNN format.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").to_compact()\n            '2025W015'\n        \"\"\"\n        return super().to_compact()\n\n    def to_datetime(self: Self) -&gt; datetime:\n        \"\"\"Converts `IsoWeekDate` to `datetime` object.\n\n        Returns:\n            `datetime` corresponding to the `IsoWeekDate`.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").to_datetime()\n            datetime.datetime(2024, 12, 30, 0, 0)\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_datetime()\n            datetime.datetime(2025, 1, 2, 0, 0)\n        \"\"\"\n        return super()._to_datetime(self.value_)\n\n    def to_date(self: Self) -&gt; date:\n        \"\"\"Converts `IsoWeekDate` to `date` object.\n\n        Returns:\n            `date` corresponding to the `IsoWeekDate`.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").to_date()\n            datetime.date(2024, 12, 30)\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").to_date()\n            datetime.date(2025, 1, 1)\n        \"\"\"\n        return self.to_datetime().date()\n\n    def to_values(self: Self) -&gt; tuple[int, ...]:\n        \"\"\"Returns the year, week and weekday as a tuple of integers.\n\n        Returns:\n            Tuple of integers representing the year and week.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_values()\n            (2025, 1, 4)\n        \"\"\"\n        return super().to_values()\n\n    # arithmetic operations\n\n    @overload\n    def __add__(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def __add__(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def __add__(\n        self: Self,\n        other: int | Iterable[int],\n    ) -&gt; Self | Generator[Self, None, None]: ...\n\n    def __add__(\n        self: Self,\n        other: int | Iterable[int],\n    ) -&gt; Self | Generator[Self, None, None]:\n        \"\"\"Addition operation.\n\n        It supports addition with the following types:\n\n        - `int`: interpreted as number of days to be added to the `IsoWeekDate` value.\n        - `Iterable` of `int`: adds each element of the iterable to the `IsoWeekDate` value and\n            returns a generator of `IsoWeekDate` objects.\n\n        Arguments:\n            other: Object to add to `IsoWeekDate`.\n\n        Returns:\n            New `IsoWeekDate` or generator of `IsoWeekDate` object(s) with the result of the addition.\n\n        Raises:\n            TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n        Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") + 1)\n        '2025-W01-2'\n        &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") + (1, 2))\n        ('2025-W01-2', '2025-W01-3')\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() + timedelta(days=other))\n        elif isinstance(other, Iterable) and all(isinstance(_other, int) for _other in other):\n            return (self + _other for _other in other)\n        else:\n            msg = f\"Cannot add type {type(other)} to `IsoWeekDate`. Addition is supported with `int` type\"\n            raise TypeError(msg)\n\n    @overload\n    def add(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def add(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def add(\n        self: Self,\n        other: int | Iterable[int],\n    ) -&gt; Self | Generator[Self, None, None]: ...\n\n    def add(self: Self, other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]:\n        \"\"\"Method equivalent of addition operator `self + other`.\n\n        It supports addition with the following types:\n\n        - `int`: interpreted as number of days to be added to the `IsoWeekDate` value.\n        - `Iterable` of `int`: adds each element of the iterable to the `IsoWeekDate` value and\n            returns a generator of `IsoWeekDate` objects.\n\n        Arguments:\n            other: Object to add to `IsoWeekDate`.\n\n        Returns:\n            New `IsoWeekDate` or generator of `IsoWeekDate` object(s) with the result of the addition.\n\n        Raises:\n            TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n        Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") + 1)\n        '2025-W01-2'\n        &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") + (1, 2))\n        ('2025-W01-2', '2025-W01-3')\n        \"\"\"\n        return self.__add__(other)\n\n    @overload\n    def __sub__(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def __sub__(self: Self, other: Self) -&gt; int: ...\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def __sub__(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...\n\n    @overload\n    def __sub__(\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]: ...\n\n    def __sub__(  # pyright: ignore[reportIncompatibleMethodOverride]\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]:\n        \"\"\"Subtraction operation.\n\n        It supports subtraction with the following types:\n\n        - `int`: interpreted as number of days to be subtracted to the `IsoWeekDate` value.\n        - `IsoWeekDate`: will result in the difference between values in days (`int` type).\n        - `Iterable` of `int` and/or `IsoWeekDate`: subtracts each element of the iterable to the\n            `IsoWeekDate`.\n\n        Arguments:\n            other: Object to subtract to `IsoWeekDate`.\n\n        Returns:\n            Results from the subtraction, can be `int`, `IsoWeekDate` or Generator of `int` and/or `IsoWeekDate`\n                depending on the type of `other`.\n\n        Raises:\n            TypeError: If `other` is not `int`, `IsoWeekDate` or `Iterable` of those types.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") - 1)\n            '2024-W52-7'\n            &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") - (1, 2))\n            ('2024-W52-7', '2024-W52-6')\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\") - IsoWeekDate(\"2024-W52-3\")\n            5\n        \"\"\"\n        if isinstance(other, int):\n            return self.from_date(self.to_date() - timedelta(days=other))\n        elif isinstance(other, IsoWeekDate) and self.offset_ == other.offset_:\n            return (self.to_date() - other.to_date()).days\n        elif isinstance(other, Iterable) and all(isinstance(_other, (int, IsoWeekDate)) for _other in other):\n            return (self - _other for _other in other)\n        else:\n            msg = (\n                f\"Cannot subtract type {type(other)} to `IsoWeekDate`. \"\n                \"Subtraction is supported with `int` and `IsoWeekDate` types\"\n            )\n            raise TypeError(msg)\n\n    @overload\n    def sub(self: Self, other: int) -&gt; Self: ...\n\n    @overload\n    def sub(self: Self, other: Self) -&gt; int: ...\n\n    @overload\n    def sub(\n        self: Self,\n        other: Iterable[int],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    def sub(self: Self, other: Iterable[Self]) -&gt; Generator[int, None, None]: ...\n\n    @overload\n    def sub(\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]: ...\n\n    def sub(\n        self: Self,\n        other: int | Self | Iterable[int | Self],\n    ) -&gt; int | Self | Generator[int | Self, None, None]:\n        \"\"\"Method equivalent of subtraction operator `self - other`.\n\n        It supports subtraction with the following types:\n\n        - `int`: interpreted as number of days to be subtracted to the `IsoWeekDate` value.\n        - `IsoWeekDate`: will result in the difference between values in days (`int` type).\n        - `Iterable[int | IsoWeekDate]`: subtracts each element of the iterable to the `IsoWeekDate`.\n\n        Arguments:\n            other: Object to subtract to `IsoWeekDate`.\n\n        Returns:\n            Results from the subtraction, can be `int`, `IsoWeekDate` or Generator of `int` and/or `IsoWeekDate`\n                depending on the type of `other`.\n\n        Raises:\n            TypeError: If `other` is not `int`, `IsoWeekDate` or `Iterable` of those types.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") - 1)\n            '2024-W52-7'\n            &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") - (1, 2))\n            ('2024-W52-7', '2024-W52-6')\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\") - IsoWeekDate(\"2024-W52-3\")\n            5\n        \"\"\"\n        return self.__sub__(other)\n\n    def next(self: Self) -&gt; Self:\n        \"\"\"Method equivalent of adding 1 to the current value.\n\n        Returns:\n            Next `IsoWeekDate` object.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").next()\n            IsoWeekDate(2025-W01-6) with offset 0:00:00\n        \"\"\"\n        return super().next()\n\n    def previous(self: Self) -&gt; Self:\n        \"\"\"Method equivalent of subtracting 1 to the current value.\n\n        Returns:\n            Previous `IsoWeekDate` object.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").previous()\n            IsoWeekDate(2024-W52-7) with offset 0:00:00\n        \"\"\"\n        return super().previous()\n\n    # Specific methods\n\n    @overload\n    @classmethod\n    def range(\n        cls: type[Self],\n        start: str | date | datetime | Self,\n        end: str | date | datetime | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: Literal[True] = True,\n    ) -&gt; Generator[str, None, None]: ...\n\n    @overload\n    @classmethod\n    def range(\n        cls: type[Self],\n        start: str | date | datetime | Self,\n        end: str | date | datetime | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: Literal[False],\n    ) -&gt; Generator[Self, None, None]: ...\n\n    @overload\n    @classmethod\n    def range(\n        cls: type[Self],\n        start: str | date | datetime | Self,\n        end: str | date | datetime | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: bool = True,\n    ) -&gt; Generator[str | Self, None, None]: ...\n\n    @classmethod\n    def range(  # pyright: ignore[reportIncompatibleMethodOverride]\n        cls: type[Self],\n        start: str | date | datetime | Self,\n        end: str | date | datetime | Self,\n        *,\n        step: int = 1,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n        as_str: bool = True,\n    ) -&gt; Generator[str | Self, None, None]:\n        \"\"\"Generates `IsoWeekDate` (or `str`) between `start` and `end` values with given `step`.\n\n        `inclusive` parameter can be used to control inclusion of `start` and/or `end` week values.\n\n        If `as_str` is flagged as `True`, it will return str values, otherwise it will return `BaseIsoWeek` objects.\n\n        Arguments:\n            start: Starting value. It can be `IsoWeekDate`, `date`, `datetime` or `str`.\n            end: Ending value. It can be `IsoWeekDate`, `date`, `datetime` or `str`.\n            step: Step between generated values, must be positive integer.\n            inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n            as_str: Whether to return `str` or `IsoWeekDate` object.\n\n        Returns:\n            Generator of `IsoWeekDate` or `str` between `start` and `end` values with given `step`.\n\n        Raises:\n            ValueError: If any of the following conditions is met:\n\n                - `start &gt; end`.\n                - `inclusive` not one of \"both\", \"left\", \"right\" or \"neither\".\n                - `step` is not strictly positive.\n            TypeError: If `step` is not an int.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; tuple(\n            ...     IsoWeekDate.range(\n            ...         start=\"2025-W01-1\",\n            ...         end=\"2025-W01-7\",\n            ...         step=2,\n            ...         inclusive=\"both\",\n            ...         as_str=True,\n            ...     )\n            ... )\n            ('2025-W01-1', '2025-W01-3', '2025-W01-5', '2025-W01-7')\n        \"\"\"\n        return super().range(\n            start=start,\n            end=end,\n            step=step,\n            inclusive=inclusive,\n            as_str=as_str,\n        )\n\n    def is_before(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Checks if `self` is before `other`.\n\n        Arguments:\n            other: Other object to compare with.\n\n        Returns:\n            True if `self` is before `other`, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").is_before(IsoWeekDate(\"2025-W02-4\"))\n            True\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").is_before(IsoWeekDate(\"2025-W01-1\"))\n            False\n        \"\"\"\n        return super().is_before(other)\n\n    def is_after(self: Self, other: Self | object) -&gt; bool:\n        \"\"\"Checks if `self` is after `other`.\n\n        Arguments:\n            other: Other object to compare with.\n\n        Returns:\n            True if `self` is after `other`, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-6\").is_after(IsoWeekDate(\"2024-W52-1\"))\n            True\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").is_after(IsoWeekDate(\"2025-W01-5\"))\n            False\n        \"\"\"\n        return super().is_after(other)\n\n    def is_between(  # pyright: ignore[reportIncompatibleMethodOverride]\n        self: Self,\n        lower_bound: Self,\n        upper_bound: Self,\n        inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n    ) -&gt; bool:\n        \"\"\"Check if `self` is between `lower_bound` and `upper_bound`.\n\n        Arguments:\n            lower_bound: Lower bound to compare with.\n            upper_bound: Upper bound to compare with.\n            inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n\n        Returns:\n            True if `self` is between `lower_bound` and `upper_bound`, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").is_between(IsoWeekDate(\"2024-W52-1\"), IsoWeekDate(\"2025-W02-3\"))\n            True\n            &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").is_between(\n            ...     IsoWeekDate(\"2025-W01-4\"), IsoWeekDate(\"2025-W02-1\"), inclusive=\"neither\"\n            ... )\n            False\n        \"\"\"\n        return super().is_between(lower_bound=lower_bound, upper_bound=upper_bound, inclusive=inclusive)\n\n    @overload\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: Literal[True],\n    ) -&gt; Generator[str, None, None]: ...\n\n    @overload\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: Literal[False],\n    ) -&gt; Generator[IsoWeekDate, None, None]: ...\n\n    @overload\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[str | IsoWeekDate, None, None]: ...\n\n    def daysout(\n        self: Self,\n        n_days: int,\n        *,\n        step: int = 1,\n        as_str: bool = True,\n    ) -&gt; Generator[str | IsoWeekDate, None, None]:\n        \"\"\"Generate range of `IsoWeekDate` (or `str`) from one to `n_days` ahead of current `value`, with given `step`.\n\n        If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeekDate` objects.\n\n        Arguments:\n            n_days: Number of days to be generated from current value.\n            step: Step between days, must be positive integer.\n            as_str: Whether to return `str` or `IsoWeekDate` object.\n\n        Returns:\n            Generator of `IsoWeekDate`s (or `str`s) from one day to `n_days` ahead of current `value` with given `step`.\n\n        Raises:\n            TypeError: If `n_days` and/or `step` is not int.\n            ValueError: If `n_days` and/or `step` is not strictly positive.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; iwd = IsoWeekDate(\"2025-W01-1\")\n            &gt;&gt;&gt; tuple(iwd.daysout(3))\n            ('2025-W01-2', '2025-W01-3', '2025-W01-4')\n            &gt;&gt;&gt; tuple(iwd.daysout(6, step=2))\n            ('2025-W01-2', '2025-W01-4', '2025-W01-6')\n        \"\"\"\n        if not isinstance(n_days, int):\n            msg = f\"`n_weeks` must be integer, found {type(n_days)} type\"\n            raise TypeError(msg)\n\n        if n_days &lt;= 0:\n            msg = f\"`n_weeks` must be strictly positive, found {n_days}\"\n            raise ValueError(msg)\n\n        start, end = (self + 1), (self + n_days)\n        return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n\n    def replace(\n        self: Self,\n        *,\n        year: int | None = None,\n        week: int | None = None,\n        weekday: int | None = None,\n    ) -&gt; Self:\n        \"\"\"Replaces the year, week and/or weekday of the `IsoWeekDate` object.\n\n        Arguments:\n            year: Year to replace. If `None`, it will not be replaced.\n            week: Week to replace. If `None`, it will not be replaced.\n            weekday: Weekday to replace. If `None`, it will not be replaced.\n\n        Returns:\n            New `IsoWeekDate` object with the replaced values.\n\n        Examples:\n            &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; iwd = IsoWeekDate(\"2025-W01-1\")\n            &gt;&gt;&gt; iwd.replace(year=2024)\n            IsoWeekDate(2024-W01-1) with offset 0:00:00\n            &gt;&gt;&gt; iwd.replace(week=2)\n            IsoWeekDate(2025-W02-1) with offset 0:00:00\n            &gt;&gt;&gt; iwd.replace(year=2024, weekday=6)\n            IsoWeekDate(2024-W01-6) with offset 0:00:00\n        \"\"\"\n        # Validation of year and week is done in the constructor of the `IsoWeekDate` class,\n        # so we can safely use them here without additional checks.\n        return self.from_values(\n            year=year if year is not None else self.year,\n            week=week if week is not None else self.week,\n            weekday=weekday if weekday is not None else self.weekday,\n        )\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.day","title":"day  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>day = weekday\n</code></pre> <p>Alias for <code>weekday</code> property.</p>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.isoweek","title":"isoweek  <code>property</code>","text":"<pre><code>isoweek: str\n</code></pre> <p>Returns iso-week string value.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>str</code> with iso-week string value (YYYY-WNN format) corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").isoweek\n'2025-W01'\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: int\n</code></pre> <p>Returns quarter number as integer.</p> <p>The first three quarters have 13 weeks, while the last one has either 13 or 14 weeks depending on the year:</p> <ul> <li>Q1: weeks from 1 to 13</li> <li>Q2: weeks from 14 to 26</li> <li>Q3: weeks from 27 to 39</li> <li>Q4: weeks from 40 to 52 (or 53 if applicable)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").quarter\n1\n&gt;&gt;&gt; IsoWeekDate(\"2025-W32-4\").quarter\n3\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.week","title":"week  <code>property</code>","text":"<pre><code>week: int\n</code></pre> <p>Returns week number as integer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").week\n1\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: int\n</code></pre> <p>Returns weekday number as integer.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>int</code> with day number as integer corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").day\n3\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.year","title":"year  <code>property</code>","text":"<pre><code>year: int\n</code></pre> <p>Returns year number as integer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").year\n2025\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__add__","title":"__add__","text":"<pre><code>__add__(other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]\n</code></pre> <p>Addition operation.</p> <p>It supports addition with the following types:</p> <ul> <li><code>int</code>: interpreted as number of days to be added to the <code>IsoWeekDate</code> value.</li> <li><code>Iterable</code> of <code>int</code>: adds each element of the iterable to the <code>IsoWeekDate</code> value and     returns a generator of <code>IsoWeekDate</code> objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Iterable[int]</code> <p>Object to add to <code>IsoWeekDate</code>.</p> required <p>Returns:</p> Type Description <code>Self | Generator[Self, None, None]</code> <p>New <code>IsoWeekDate</code> or generator of <code>IsoWeekDate</code> object(s) with the result of the addition.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code> or <code>Iterable</code> of <code>int</code>.</p> <p>Examples:</p> <p>from iso_week_date import IsoWeekDate</p> <p>str(IsoWeekDate(\"2025-W01-1\") + 1) '2025-W01-2' tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") + (1, 2)) ('2025-W01-2', '2025-W01-3')</p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __add__(\n    self: Self,\n    other: int | Iterable[int],\n) -&gt; Self | Generator[Self, None, None]:\n    \"\"\"Addition operation.\n\n    It supports addition with the following types:\n\n    - `int`: interpreted as number of days to be added to the `IsoWeekDate` value.\n    - `Iterable` of `int`: adds each element of the iterable to the `IsoWeekDate` value and\n        returns a generator of `IsoWeekDate` objects.\n\n    Arguments:\n        other: Object to add to `IsoWeekDate`.\n\n    Returns:\n        New `IsoWeekDate` or generator of `IsoWeekDate` object(s) with the result of the addition.\n\n    Raises:\n        TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n    Examples:\n    &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") + 1)\n    '2025-W01-2'\n    &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") + (1, 2))\n    ('2025-W01-2', '2025-W01-3')\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() + timedelta(days=other))\n    elif isinstance(other, Iterable) and all(isinstance(_other, int) for _other in other):\n        return (self + _other for _other in other)\n    else:\n        msg = f\"Cannot add type {type(other)} to `IsoWeekDate`. Addition is supported with `int` type\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Equality operator.</p> <p>Two ISO Week objects are considered equal if and only if they have the same <code>offset_</code> and the same <code>value_</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if objects are equal, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == IsoWeekDate(\"2025-W01-3\")\nTrue\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == IsoWeekDate(\"2025-W02-1\")\nFalse\n&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == CustomIsoWeekDate(\"2025-W01-3\")\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __eq__(self: Self, other: object) -&gt; bool:\n    \"\"\"Equality operator.\n\n    Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if objects are equal, `False` otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == IsoWeekDate(\"2025-W01-3\")\n        True\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == IsoWeekDate(\"2025-W02-1\")\n        False\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") == CustomIsoWeekDate(\"2025-W01-3\")\n        False\n    \"\"\"\n    return super().__eq__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self | object) -&gt; bool\n</code></pre> <p>Greater than or equal operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is greater than or equal to <code>other</code>, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= IsoWeekDate(\"2025-W02-1\")\nFalse\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= IsoWeekDate(\"2025-W01-2\")\nTrue\n&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= CustomIsoWeekDate(\"2025-W01-3\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= \"2025-W01-3\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __ge__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Greater than or equal operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n       other: Object to compare with.\n\n    Returns:\n        `True` if self is greater than or equal to `other`, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= IsoWeekDate(\"2025-W02-1\")\n        False\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= IsoWeekDate(\"2025-W01-2\")\n        True\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= CustomIsoWeekDate(\"2025-W01-3\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt;= \"2025-W01-3\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__ge__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self | object) -&gt; bool\n</code></pre> <p>Greater than operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is greater than other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; IsoWeekDate(\"2025-W02-1\")\nFalse\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; IsoWeekDate(\"2024-W52-7\")\nTrue\n&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; CustomIsoWeekDate(\"2025-W01-3\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; \"2025-W01-3\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __gt__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Greater than operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is greater than other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; IsoWeekDate(\"2025-W02-1\")\n        False\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; IsoWeekDate(\"2024-W52-7\")\n        True\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; CustomIsoWeekDate(\"2025-W01-3\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &gt; \"2025-W01-3\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__gt__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Returns the hash of the object.</p> <p>The hash is calculated based on the <code>value_</code> attribute and the <code>offset_</code> attribute. This allows for proper hashing and comparison of IsoWeekDate objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>Hash of the IsoWeekDate object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; hash(IsoWeekDate(\"2025-W01-3\"))\n-7997434344089344162\n</code></pre> <pre><code>&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; hash(CustomIsoWeekDate(\"2025-W01-3\"))\n455721150121118585\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __hash__(self: Self) -&gt; int:\n    \"\"\"Returns the hash of the object.\n\n    The hash is calculated based on the `value_` attribute and the `offset_` attribute.\n    This allows for proper hashing and comparison of IsoWeekDate objects.\n\n    Returns:\n        Hash of the IsoWeekDate object.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; hash(IsoWeekDate(\"2025-W01-3\"))  # doctest: +SKIP\n        -7997434344089344162\n\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; hash(CustomIsoWeekDate(\"2025-W01-3\"))  # doctest: +SKIP\n        455721150121118585\n    \"\"\"\n    return super().__hash__()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__le__","title":"__le__","text":"<pre><code>__le__(other: Self | object) -&gt; bool\n</code></pre> <p>Less than or equal operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is less than or equal to other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= IsoWeekDate(\"2025-W02-1\")\nTrue\n&gt;&gt;&gt; IsoWeekDate(\"2025-W02-7\") &lt;= IsoWeekDate(\"2025-W01-3\")\nFalse\n&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= CustomIsoWeekDate(\"2025-W01-3\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= \"2025-W01-3\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __le__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Less than or equal operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is less than or equal to other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= IsoWeekDate(\"2025-W02-1\")\n        True\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W02-7\") &lt;= IsoWeekDate(\"2025-W01-3\")\n        False\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= CustomIsoWeekDate(\"2025-W01-3\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt;= \"2025-W01-3\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__le__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self | object) -&gt; bool\n</code></pre> <p>Less than operator.</p> <p>Comparing two ISO Week objects is only possible if they have the same <code>offset_</code>.</p> <p>If that's the case than it's enough to compare their values (as <code>str</code>) due to its lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if self is less than other, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not of same type or it has a different offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; IsoWeekDate(\"2025-W02-1\")\nTrue\n&gt;&gt;&gt; IsoWeekDate(\"2025-W02-7\") &lt; IsoWeekDate(\"2025-W01-3\")\nFalse\n&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; CustomIsoWeekDate(\"2025-W01-3\")\nTraceback (most recent call last):\nTypeError: ...\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; \"2025-W01-3\"\nTraceback (most recent call last):\nTypeError: ...\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __lt__(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Less than operator.\n\n    Comparing two ISO Week objects is only possible if they have the same `offset_`.\n\n    If that's the case than it's enough to compare their values (as `str`) due to its lexicographical order.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if self is less than other, `False` otherwise.\n\n    Raises:\n        TypeError: If `other` is not of same type or it has a different offset.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; IsoWeekDate(\"2025-W02-1\")\n        True\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W02-7\") &lt; IsoWeekDate(\"2025-W01-3\")\n        False\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; CustomIsoWeekDate(\"2025-W01-3\")\n        Traceback (most recent call last):\n        TypeError: ...\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") &lt; \"2025-W01-3\"\n        Traceback (most recent call last):\n        TypeError: ...\n    \"\"\"\n    return super().__lt__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: object) -&gt; bool\n</code></pre> <p>Inequality operator.</p> <p>Two ISO Week objects are considered equal if and only if they have the same <code>offset_</code> and the same <code>value_</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if objects are not equal, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != IsoWeekDate(\"2025-W01-3\")\nFalse\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != IsoWeekDate(\"2025-W02-1\")\nTrue\n&gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n...     offset_ = timedelta(days=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != CustomIsoWeekDate(\"2025-W01-3\")\nTrue\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __ne__(self: Self, other: object) -&gt; bool:\n    \"\"\"Inequality operator.\n\n    Two ISO Week objects are considered equal if and only if they have the same `offset_` and the same `value_`.\n\n    Arguments:\n        other: Object to compare with.\n\n    Returns:\n        `True` if objects are _not_ equal, `False` otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != IsoWeekDate(\"2025-W01-3\")\n        False\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != IsoWeekDate(\"2025-W02-1\")\n        True\n        &gt;&gt;&gt; class CustomIsoWeekDate(IsoWeekDate):\n        ...     offset_ = timedelta(days=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\") != CustomIsoWeekDate(\"2025-W01-3\")\n        True\n    \"\"\"\n    return super().__ne__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Self\n</code></pre> <p>Returns the next ISO week date.</p> <p>This is equivalent to adding 1 to the current ISO week date.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Next ISO week date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; next(IsoWeekDate(\"2025-W01-4\"))\nIsoWeekDate(2025-W01-5) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __next__(self: Self) -&gt; Self:\n    \"\"\"Returns the next ISO week date.\n\n    This is equivalent to adding 1 to the current ISO week date.\n\n    Returns:\n        Next ISO week date.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; next(IsoWeekDate(\"2025-W01-4\"))\n        IsoWeekDate(2025-W01-5) with offset 0:00:00\n    \"\"\"\n    return super().__next__()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Custom representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the IsoWeekDate object: class name, value and offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\")\nIsoWeekDate(2025-W01-1) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __repr__(self: Self) -&gt; str:\n    \"\"\"Custom representation.\n\n    Returns:\n        String representation of the IsoWeekDate object: class name, value and offset.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\")\n        IsoWeekDate(2025-W01-1) with offset 0:00:00\n    \"\"\"\n    return super().__repr__()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Custom string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the IsoWeekDate object in the format \"YYYY-WNN-D\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\"))\n'2025-W01-1'\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __str__(self: Self) -&gt; str:\n    \"\"\"Custom string representation.\n\n    Returns:\n        String representation of the IsoWeekDate object in the format \"YYYY-WNN-D\".\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\"))\n        '2025-W01-1'\n    \"\"\"\n    return super().__str__()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: int | Self | Iterable[int | Self]) -&gt; int | Self | Generator[int | Self, None, None]\n</code></pre> <p>Subtraction operation.</p> <p>It supports subtraction with the following types:</p> <ul> <li><code>int</code>: interpreted as number of days to be subtracted to the <code>IsoWeekDate</code> value.</li> <li><code>IsoWeekDate</code>: will result in the difference between values in days (<code>int</code> type).</li> <li><code>Iterable</code> of <code>int</code> and/or <code>IsoWeekDate</code>: subtracts each element of the iterable to the     <code>IsoWeekDate</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Self | Iterable[int | Self]</code> <p>Object to subtract to <code>IsoWeekDate</code>.</p> required <p>Returns:</p> Type Description <code>int | Self | Generator[int | Self, None, None]</code> <p>Results from the subtraction, can be <code>int</code>, <code>IsoWeekDate</code> or Generator of <code>int</code> and/or <code>IsoWeekDate</code> depending on the type of <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>IsoWeekDate</code> or <code>Iterable</code> of those types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") - 1)\n'2024-W52-7'\n&gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") - (1, 2))\n('2024-W52-7', '2024-W52-6')\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\") - IsoWeekDate(\"2024-W52-3\")\n5\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def __sub__(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self: Self,\n    other: int | Self | Iterable[int | Self],\n) -&gt; int | Self | Generator[int | Self, None, None]:\n    \"\"\"Subtraction operation.\n\n    It supports subtraction with the following types:\n\n    - `int`: interpreted as number of days to be subtracted to the `IsoWeekDate` value.\n    - `IsoWeekDate`: will result in the difference between values in days (`int` type).\n    - `Iterable` of `int` and/or `IsoWeekDate`: subtracts each element of the iterable to the\n        `IsoWeekDate`.\n\n    Arguments:\n        other: Object to subtract to `IsoWeekDate`.\n\n    Returns:\n        Results from the subtraction, can be `int`, `IsoWeekDate` or Generator of `int` and/or `IsoWeekDate`\n            depending on the type of `other`.\n\n    Raises:\n        TypeError: If `other` is not `int`, `IsoWeekDate` or `Iterable` of those types.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") - 1)\n        '2024-W52-7'\n        &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") - (1, 2))\n        ('2024-W52-7', '2024-W52-6')\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\") - IsoWeekDate(\"2024-W52-3\")\n        5\n    \"\"\"\n    if isinstance(other, int):\n        return self.from_date(self.to_date() - timedelta(days=other))\n    elif isinstance(other, IsoWeekDate) and self.offset_ == other.offset_:\n        return (self.to_date() - other.to_date()).days\n    elif isinstance(other, Iterable) and all(isinstance(_other, (int, IsoWeekDate)) for _other in other):\n        return (self - _other for _other in other)\n    else:\n        msg = (\n            f\"Cannot subtract type {type(other)} to `IsoWeekDate`. \"\n            \"Subtraction is supported with `int` and `IsoWeekDate` types\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.add","title":"add","text":"<pre><code>add(other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]\n</code></pre> <p>Method equivalent of addition operator <code>self + other</code>.</p> <p>It supports addition with the following types:</p> <ul> <li><code>int</code>: interpreted as number of days to be added to the <code>IsoWeekDate</code> value.</li> <li><code>Iterable</code> of <code>int</code>: adds each element of the iterable to the <code>IsoWeekDate</code> value and     returns a generator of <code>IsoWeekDate</code> objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Iterable[int]</code> <p>Object to add to <code>IsoWeekDate</code>.</p> required <p>Returns:</p> Type Description <code>Self | Generator[Self, None, None]</code> <p>New <code>IsoWeekDate</code> or generator of <code>IsoWeekDate</code> object(s) with the result of the addition.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code> or <code>Iterable</code> of <code>int</code>.</p> <p>Examples:</p> <p>from iso_week_date import IsoWeekDate</p> <p>str(IsoWeekDate(\"2025-W01-1\") + 1) '2025-W01-2' tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") + (1, 2)) ('2025-W01-2', '2025-W01-3')</p> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def add(self: Self, other: int | Iterable[int]) -&gt; Self | Generator[Self, None, None]:\n    \"\"\"Method equivalent of addition operator `self + other`.\n\n    It supports addition with the following types:\n\n    - `int`: interpreted as number of days to be added to the `IsoWeekDate` value.\n    - `Iterable` of `int`: adds each element of the iterable to the `IsoWeekDate` value and\n        returns a generator of `IsoWeekDate` objects.\n\n    Arguments:\n        other: Object to add to `IsoWeekDate`.\n\n    Returns:\n        New `IsoWeekDate` or generator of `IsoWeekDate` object(s) with the result of the addition.\n\n    Raises:\n        TypeError: If `other` is not `int` or `Iterable` of `int`.\n\n    Examples:\n    &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") + 1)\n    '2025-W01-2'\n    &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") + (1, 2))\n    ('2025-W01-2', '2025-W01-3')\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.daysout","title":"daysout","text":"<pre><code>daysout(n_days: int, *, step: int = 1, as_str: bool = True) -&gt; Generator[str | IsoWeekDate, None, None]\n</code></pre> <p>Generate range of <code>IsoWeekDate</code> (or <code>str</code>) from one to <code>n_days</code> ahead of current <code>value</code>, with given <code>step</code>.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return <code>str</code> values, otherwise it will return <code>IsoWeekDate</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>n_days</code> <code>int</code> <p>Number of days to be generated from current value.</p> required <code>step</code> <code>int</code> <p>Step between days, must be positive integer.</p> <code>1</code> <code>as_str</code> <code>bool</code> <p>Whether to return <code>str</code> or <code>IsoWeekDate</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>Generator of <code>IsoWeekDate</code>s (or <code>str</code>s) from one day to <code>n_days</code> ahead of current <code>value</code> with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>n_days</code> and/or <code>step</code> is not int.</p> <code>ValueError</code> <p>If <code>n_days</code> and/or <code>step</code> is not strictly positive.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; iwd = IsoWeekDate(\"2025-W01-1\")\n&gt;&gt;&gt; tuple(iwd.daysout(3))\n('2025-W01-2', '2025-W01-3', '2025-W01-4')\n&gt;&gt;&gt; tuple(iwd.daysout(6, step=2))\n('2025-W01-2', '2025-W01-4', '2025-W01-6')\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def daysout(\n    self: Self,\n    n_days: int,\n    *,\n    step: int = 1,\n    as_str: bool = True,\n) -&gt; Generator[str | IsoWeekDate, None, None]:\n    \"\"\"Generate range of `IsoWeekDate` (or `str`) from one to `n_days` ahead of current `value`, with given `step`.\n\n    If `as_str` is flagged as `True`, it will return `str` values, otherwise it will return `IsoWeekDate` objects.\n\n    Arguments:\n        n_days: Number of days to be generated from current value.\n        step: Step between days, must be positive integer.\n        as_str: Whether to return `str` or `IsoWeekDate` object.\n\n    Returns:\n        Generator of `IsoWeekDate`s (or `str`s) from one day to `n_days` ahead of current `value` with given `step`.\n\n    Raises:\n        TypeError: If `n_days` and/or `step` is not int.\n        ValueError: If `n_days` and/or `step` is not strictly positive.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; iwd = IsoWeekDate(\"2025-W01-1\")\n        &gt;&gt;&gt; tuple(iwd.daysout(3))\n        ('2025-W01-2', '2025-W01-3', '2025-W01-4')\n        &gt;&gt;&gt; tuple(iwd.daysout(6, step=2))\n        ('2025-W01-2', '2025-W01-4', '2025-W01-6')\n    \"\"\"\n    if not isinstance(n_days, int):\n        msg = f\"`n_weeks` must be integer, found {type(n_days)} type\"\n        raise TypeError(msg)\n\n    if n_days &lt;= 0:\n        msg = f\"`n_weeks` must be strictly positive, found {n_days}\"\n        raise ValueError(msg)\n\n    start, end = (self + 1), (self + n_days)\n    return self.range(start, end, step=step, inclusive=\"both\", as_str=as_str)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.from_compact","title":"from_compact  <code>classmethod</code>","text":"<pre><code>from_compact(_str: str) -&gt; Self\n</code></pre> <p>Create an IsoWeekDate instance from a compact string in YYYYNND format.</p> <p>Parameters:</p> Name Type Description Default <code>_str</code> <code>str</code> <p>String in YYYYNND format.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeekDate instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_str</code> is not a string.</p> <code>ValueError</code> <p>If <code>_str</code> does not match the expected format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate.from_compact(\"2025W013\")\nIsoWeekDate(2025-W01-3) with offset 0:00:00\n&gt;&gt;&gt; IsoWeekDate.from_compact(\"2025W537\")\nTraceback (most recent call last):\nValueError: Invalid week number. Year 2025 has only 52 weeks.\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef from_compact(cls: type[Self], _str: str, /) -&gt; Self:\n    \"\"\"Create an IsoWeekDate instance from a compact string in YYYYNND format.\n\n    Arguments:\n        _str: String in YYYYNND format.\n\n    Returns:\n        IsoWeekDate instance.\n\n    Raises:\n        TypeError: If `_str` is not a string.\n        ValueError: If `_str` does not match the expected format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate.from_compact(\"2025W013\")\n        IsoWeekDate(2025-W01-3) with offset 0:00:00\n        &gt;&gt;&gt; IsoWeekDate.from_compact(\"2025W537\")\n        Traceback (most recent call last):\n        ValueError: Invalid week number. Year 2025 has only 52 weeks.\n    \"\"\"\n    return super().from_compact(_str)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.from_date","title":"from_date  <code>classmethod</code>","text":"<pre><code>from_date(_date: date) -&gt; Self\n</code></pre> <p>Create an IsoWeekDate instance from a date object.</p> <p>Parameters:</p> Name Type Description Default <code>_date</code> <code>date</code> <p>Date object.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeekDate instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_date</code> is not a date object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate.from_date(date(2024, 12, 31))\nIsoWeekDate(2025-W01-2) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef from_date(cls: type[Self], _date: date, /) -&gt; Self:\n    \"\"\"Create an IsoWeekDate instance from a date object.\n\n    Arguments:\n        _date: Date object.\n\n    Returns:\n        IsoWeekDate instance.\n\n    Raises:\n        TypeError: If `_date` is not a date object.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate.from_date(date(2024, 12, 31))\n        IsoWeekDate(2025-W01-2) with offset 0:00:00\n    \"\"\"\n    return super().from_date(_date)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.from_datetime","title":"from_datetime  <code>classmethod</code>","text":"<pre><code>from_datetime(_datetime: datetime) -&gt; Self\n</code></pre> <p>Create an IsoWeekDate instance from a datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>_datetime</code> <code>datetime</code> <p>Datetime object.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeekDate instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_datetime</code> is not a datetime object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate.from_datetime(datetime(2024, 12, 31))\nIsoWeekDate(2025-W01-2) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef from_datetime(cls: type[Self], _datetime: datetime, /) -&gt; Self:\n    \"\"\"Create an IsoWeekDate instance from a datetime object.\n\n    Arguments:\n        _datetime: Datetime object.\n\n    Returns:\n        IsoWeekDate instance.\n\n    Raises:\n        TypeError: If `_datetime` is not a datetime object.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate.from_datetime(datetime(2024, 12, 31))\n        IsoWeekDate(2025-W01-2) with offset 0:00:00\n    \"\"\"\n    return super().from_datetime(_datetime)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(_str: str) -&gt; Self\n</code></pre> <p>Create an IsoWeekDate instance from a string in YYYY-WNN-D format.</p> <p>Parameters:</p> Name Type Description Default <code>_str</code> <code>str</code> <p>String in YYYY-WNN-D format.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeekDate instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>_str</code> is not a string.</p> <code>ValueError</code> <p>If <code>_str</code> does not match the expected format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate.from_string(\"2025-W01-4\")\nIsoWeekDate(2025-W01-4) with offset 0:00:00\n&gt;&gt;&gt; IsoWeekDate.from_string(\"2025-W53-1\")\nTraceback (most recent call last):\nValueError: Invalid week number. Year 2025 has only 52 weeks.\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef from_string(cls: type[Self], _str: str, /) -&gt; Self:\n    \"\"\"Create an IsoWeekDate instance from a string in YYYY-WNN-D format.\n\n    Arguments:\n        _str: String in YYYY-WNN-D format.\n\n    Returns:\n        IsoWeekDate instance.\n\n    Raises:\n        TypeError: If `_str` is not a string.\n        ValueError: If `_str` does not match the expected format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate.from_string(\"2025-W01-4\")\n        IsoWeekDate(2025-W01-4) with offset 0:00:00\n        &gt;&gt;&gt; IsoWeekDate.from_string(\"2025-W53-1\")\n        Traceback (most recent call last):\n        ValueError: Invalid week number. Year 2025 has only 52 weeks.\n    \"\"\"\n    return super().from_string(_str)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.from_today","title":"from_today  <code>classmethod</code>","text":"<pre><code>from_today(time_zone: tzinfo | None = None) -&gt; Self\n</code></pre> <p>Create an IsoWeekDate instance from the current date.</p> <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeekDate instance representing the current date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate.from_today() == IsoWeekDate.from_date(datetime.now().date())\nTrue\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef from_today(cls: type[Self], time_zone: tzinfo | None = None) -&gt; Self:\n    \"\"\"Create an IsoWeekDate instance from the current date.\n\n    Returns:\n        IsoWeekDate instance representing the current date.\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate.from_today() == IsoWeekDate.from_date(datetime.now().date())\n        True\n    \"\"\"\n    return cls.from_datetime(datetime.now(tz=time_zone))\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.from_values","title":"from_values  <code>classmethod</code>","text":"<pre><code>from_values(year: int, week: int, weekday: int) -&gt; Self\n</code></pre> <p>Create an IsoWeekDate instance from year and week number.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year number (YYYY).</p> required <code>week</code> <code>int</code> <p>Week number (NN).</p> required <code>weekday</code> <code>int</code> <p>Weekday number (D).</p> required <p>Returns:</p> Type Description <code>Self</code> <p>IsoWeekDate instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate.from_values(year=2025, week=1, weekday=4)\nIsoWeekDate(2025-W01-4) with offset 0:00:00\n&gt;&gt;&gt; IsoWeekDate.from_values(2025, 53, 1)\nTraceback (most recent call last):\nValueError: Invalid week number. Year 2025 has only 52 weeks.\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef from_values(cls: type[Self], year: int, week: int, weekday: int) -&gt; Self:\n    \"\"\"Create an IsoWeekDate instance from year and week number.\n\n    Arguments:\n        year: Year number (YYYY).\n        week: Week number (NN).\n        weekday: Weekday number (D).\n\n    Returns:\n        IsoWeekDate instance.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate.from_values(year=2025, week=1, weekday=4)\n        IsoWeekDate(2025-W01-4) with offset 0:00:00\n        &gt;&gt;&gt; IsoWeekDate.from_values(2025, 53, 1)\n        Traceback (most recent call last):\n        ValueError: Invalid week number. Year 2025 has only 52 weeks.\n    \"\"\"\n    value = (\n        cls._format.replace(\"YYYY\", str(year).zfill(4)).replace(\"NN\", str(week).zfill(2)).replace(\"D\", str(weekday))\n    )\n    return cls(value)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.is_after","title":"is_after","text":"<pre><code>is_after(other: Self | object) -&gt; bool\n</code></pre> <p>Checks if <code>self</code> is after <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>self</code> is after <code>other</code>, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-6\").is_after(IsoWeekDate(\"2024-W52-1\"))\nTrue\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").is_after(IsoWeekDate(\"2025-W01-5\"))\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def is_after(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Checks if `self` is after `other`.\n\n    Arguments:\n        other: Other object to compare with.\n\n    Returns:\n        True if `self` is after `other`, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-6\").is_after(IsoWeekDate(\"2024-W52-1\"))\n        True\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").is_after(IsoWeekDate(\"2025-W01-5\"))\n        False\n    \"\"\"\n    return super().is_after(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.is_before","title":"is_before","text":"<pre><code>is_before(other: Self | object) -&gt; bool\n</code></pre> <p>Checks if <code>self</code> is before <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | object</code> <p>Other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>self</code> is before <code>other</code>, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").is_before(IsoWeekDate(\"2025-W02-4\"))\nTrue\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").is_before(IsoWeekDate(\"2025-W01-1\"))\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def is_before(self: Self, other: Self | object) -&gt; bool:\n    \"\"\"Checks if `self` is before `other`.\n\n    Arguments:\n        other: Other object to compare with.\n\n    Returns:\n        True if `self` is before `other`, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").is_before(IsoWeekDate(\"2025-W02-4\"))\n        True\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").is_before(IsoWeekDate(\"2025-W01-1\"))\n        False\n    \"\"\"\n    return super().is_before(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.is_between","title":"is_between","text":"<pre><code>is_between(lower_bound: Self, upper_bound: Self, inclusive: Literal['both', 'left', 'right', 'neither'] = 'both') -&gt; bool\n</code></pre> <p>Check if <code>self</code> is between <code>lower_bound</code> and <code>upper_bound</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Self</code> <p>Lower bound to compare with.</p> required <code>upper_bound</code> <code>Self</code> <p>Upper bound to compare with.</p> required <code>inclusive</code> <code>Literal['both', 'left', 'right', 'neither']</code> <p>Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".</p> <code>'both'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>self</code> is between <code>lower_bound</code> and <code>upper_bound</code>, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").is_between(IsoWeekDate(\"2024-W52-1\"), IsoWeekDate(\"2025-W02-3\"))\nTrue\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").is_between(\n...     IsoWeekDate(\"2025-W01-4\"), IsoWeekDate(\"2025-W02-1\"), inclusive=\"neither\"\n... )\nFalse\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def is_between(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self: Self,\n    lower_bound: Self,\n    upper_bound: Self,\n    inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n) -&gt; bool:\n    \"\"\"Check if `self` is between `lower_bound` and `upper_bound`.\n\n    Arguments:\n        lower_bound: Lower bound to compare with.\n        upper_bound: Upper bound to compare with.\n        inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n\n    Returns:\n        True if `self` is between `lower_bound` and `upper_bound`, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").is_between(IsoWeekDate(\"2024-W52-1\"), IsoWeekDate(\"2025-W02-3\"))\n        True\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").is_between(\n        ...     IsoWeekDate(\"2025-W01-4\"), IsoWeekDate(\"2025-W02-1\"), inclusive=\"neither\"\n        ... )\n        False\n    \"\"\"\n    return super().is_between(lower_bound=lower_bound, upper_bound=upper_bound, inclusive=inclusive)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.next","title":"next","text":"<pre><code>next() -&gt; Self\n</code></pre> <p>Method equivalent of adding 1 to the current value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Next <code>IsoWeekDate</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").next()\nIsoWeekDate(2025-W01-6) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def next(self: Self) -&gt; Self:\n    \"\"\"Method equivalent of adding 1 to the current value.\n\n    Returns:\n        Next `IsoWeekDate` object.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").next()\n        IsoWeekDate(2025-W01-6) with offset 0:00:00\n    \"\"\"\n    return super().next()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.previous","title":"previous","text":"<pre><code>previous() -&gt; Self\n</code></pre> <p>Method equivalent of subtracting 1 to the current value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Previous <code>IsoWeekDate</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").previous()\nIsoWeekDate(2024-W52-7) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def previous(self: Self) -&gt; Self:\n    \"\"\"Method equivalent of subtracting 1 to the current value.\n\n    Returns:\n        Previous `IsoWeekDate` object.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").previous()\n        IsoWeekDate(2024-W52-7) with offset 0:00:00\n    \"\"\"\n    return super().previous()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.range","title":"range  <code>classmethod</code>","text":"<pre><code>range(start: str | date | datetime | Self, end: str | date | datetime | Self, *, step: int = 1, inclusive: Literal['both', 'left', 'right', 'neither'] = 'both', as_str: bool = True) -&gt; Generator[str | Self, None, None]\n</code></pre> <p>Generates <code>IsoWeekDate</code> (or <code>str</code>) between <code>start</code> and <code>end</code> values with given <code>step</code>.</p> <p><code>inclusive</code> parameter can be used to control inclusion of <code>start</code> and/or <code>end</code> week values.</p> <p>If <code>as_str</code> is flagged as <code>True</code>, it will return str values, otherwise it will return <code>BaseIsoWeek</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | date | datetime | Self</code> <p>Starting value. It can be <code>IsoWeekDate</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <code>end</code> <code>str | date | datetime | Self</code> <p>Ending value. It can be <code>IsoWeekDate</code>, <code>date</code>, <code>datetime</code> or <code>str</code>.</p> required <code>step</code> <code>int</code> <p>Step between generated values, must be positive integer.</p> <code>1</code> <code>inclusive</code> <code>Literal['both', 'left', 'right', 'neither']</code> <p>Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".</p> <code>'both'</code> <code>as_str</code> <code>bool</code> <p>Whether to return <code>str</code> or <code>IsoWeekDate</code> object.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>Generator of <code>IsoWeekDate</code> or <code>str</code> between <code>start</code> and <code>end</code> values with given <code>step</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the following conditions is met:</p> <ul> <li><code>start &gt; end</code>.</li> <li><code>inclusive</code> not one of \"both\", \"left\", \"right\" or \"neither\".</li> <li><code>step</code> is not strictly positive.</li> </ul> <code>TypeError</code> <p>If <code>step</code> is not an int.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; tuple(\n...     IsoWeekDate.range(\n...         start=\"2025-W01-1\",\n...         end=\"2025-W01-7\",\n...         step=2,\n...         inclusive=\"both\",\n...         as_str=True,\n...     )\n... )\n('2025-W01-1', '2025-W01-3', '2025-W01-5', '2025-W01-7')\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>@classmethod\ndef range(  # pyright: ignore[reportIncompatibleMethodOverride]\n    cls: type[Self],\n    start: str | date | datetime | Self,\n    end: str | date | datetime | Self,\n    *,\n    step: int = 1,\n    inclusive: Literal[\"both\", \"left\", \"right\", \"neither\"] = \"both\",\n    as_str: bool = True,\n) -&gt; Generator[str | Self, None, None]:\n    \"\"\"Generates `IsoWeekDate` (or `str`) between `start` and `end` values with given `step`.\n\n    `inclusive` parameter can be used to control inclusion of `start` and/or `end` week values.\n\n    If `as_str` is flagged as `True`, it will return str values, otherwise it will return `BaseIsoWeek` objects.\n\n    Arguments:\n        start: Starting value. It can be `IsoWeekDate`, `date`, `datetime` or `str`.\n        end: Ending value. It can be `IsoWeekDate`, `date`, `datetime` or `str`.\n        step: Step between generated values, must be positive integer.\n        inclusive: Inclusive type, can be one of \"both\", \"left\", \"right\" or \"neither\".\n        as_str: Whether to return `str` or `IsoWeekDate` object.\n\n    Returns:\n        Generator of `IsoWeekDate` or `str` between `start` and `end` values with given `step`.\n\n    Raises:\n        ValueError: If any of the following conditions is met:\n\n            - `start &gt; end`.\n            - `inclusive` not one of \"both\", \"left\", \"right\" or \"neither\".\n            - `step` is not strictly positive.\n        TypeError: If `step` is not an int.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; tuple(\n        ...     IsoWeekDate.range(\n        ...         start=\"2025-W01-1\",\n        ...         end=\"2025-W01-7\",\n        ...         step=2,\n        ...         inclusive=\"both\",\n        ...         as_str=True,\n        ...     )\n        ... )\n        ('2025-W01-1', '2025-W01-3', '2025-W01-5', '2025-W01-7')\n    \"\"\"\n    return super().range(\n        start=start,\n        end=end,\n        step=step,\n        inclusive=inclusive,\n        as_str=as_str,\n    )\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.replace","title":"replace","text":"<pre><code>replace(*, year: int | None = None, week: int | None = None, weekday: int | None = None) -&gt; Self\n</code></pre> <p>Replaces the year, week and/or weekday of the <code>IsoWeekDate</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int | None</code> <p>Year to replace. If <code>None</code>, it will not be replaced.</p> <code>None</code> <code>week</code> <code>int | None</code> <p>Week to replace. If <code>None</code>, it will not be replaced.</p> <code>None</code> <code>weekday</code> <code>int | None</code> <p>Weekday to replace. If <code>None</code>, it will not be replaced.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>New <code>IsoWeekDate</code> object with the replaced values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; iwd = IsoWeekDate(\"2025-W01-1\")\n&gt;&gt;&gt; iwd.replace(year=2024)\nIsoWeekDate(2024-W01-1) with offset 0:00:00\n&gt;&gt;&gt; iwd.replace(week=2)\nIsoWeekDate(2025-W02-1) with offset 0:00:00\n&gt;&gt;&gt; iwd.replace(year=2024, weekday=6)\nIsoWeekDate(2024-W01-6) with offset 0:00:00\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def replace(\n    self: Self,\n    *,\n    year: int | None = None,\n    week: int | None = None,\n    weekday: int | None = None,\n) -&gt; Self:\n    \"\"\"Replaces the year, week and/or weekday of the `IsoWeekDate` object.\n\n    Arguments:\n        year: Year to replace. If `None`, it will not be replaced.\n        week: Week to replace. If `None`, it will not be replaced.\n        weekday: Weekday to replace. If `None`, it will not be replaced.\n\n    Returns:\n        New `IsoWeekDate` object with the replaced values.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; iwd = IsoWeekDate(\"2025-W01-1\")\n        &gt;&gt;&gt; iwd.replace(year=2024)\n        IsoWeekDate(2024-W01-1) with offset 0:00:00\n        &gt;&gt;&gt; iwd.replace(week=2)\n        IsoWeekDate(2025-W02-1) with offset 0:00:00\n        &gt;&gt;&gt; iwd.replace(year=2024, weekday=6)\n        IsoWeekDate(2024-W01-6) with offset 0:00:00\n    \"\"\"\n    # Validation of year and week is done in the constructor of the `IsoWeekDate` class,\n    # so we can safely use them here without additional checks.\n    return self.from_values(\n        year=year if year is not None else self.year,\n        week=week if week is not None else self.week,\n        weekday=weekday if weekday is not None else self.weekday,\n    )\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.sub","title":"sub","text":"<pre><code>sub(other: int | Self | Iterable[int | Self]) -&gt; int | Self | Generator[int | Self, None, None]\n</code></pre> <p>Method equivalent of subtraction operator <code>self - other</code>.</p> <p>It supports subtraction with the following types:</p> <ul> <li><code>int</code>: interpreted as number of days to be subtracted to the <code>IsoWeekDate</code> value.</li> <li><code>IsoWeekDate</code>: will result in the difference between values in days (<code>int</code> type).</li> <li><code>Iterable[int | IsoWeekDate]</code>: subtracts each element of the iterable to the <code>IsoWeekDate</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int | Self | Iterable[int | Self]</code> <p>Object to subtract to <code>IsoWeekDate</code>.</p> required <p>Returns:</p> Type Description <code>int | Self | Generator[int | Self, None, None]</code> <p>Results from the subtraction, can be <code>int</code>, <code>IsoWeekDate</code> or Generator of <code>int</code> and/or <code>IsoWeekDate</code> depending on the type of <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not <code>int</code>, <code>IsoWeekDate</code> or <code>Iterable</code> of those types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") - 1)\n'2024-W52-7'\n&gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") - (1, 2))\n('2024-W52-7', '2024-W52-6')\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\") - IsoWeekDate(\"2024-W52-3\")\n5\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def sub(\n    self: Self,\n    other: int | Self | Iterable[int | Self],\n) -&gt; int | Self | Generator[int | Self, None, None]:\n    \"\"\"Method equivalent of subtraction operator `self - other`.\n\n    It supports subtraction with the following types:\n\n    - `int`: interpreted as number of days to be subtracted to the `IsoWeekDate` value.\n    - `IsoWeekDate`: will result in the difference between values in days (`int` type).\n    - `Iterable[int | IsoWeekDate]`: subtracts each element of the iterable to the `IsoWeekDate`.\n\n    Arguments:\n        other: Object to subtract to `IsoWeekDate`.\n\n    Returns:\n        Results from the subtraction, can be `int`, `IsoWeekDate` or Generator of `int` and/or `IsoWeekDate`\n            depending on the type of `other`.\n\n    Raises:\n        TypeError: If `other` is not `int`, `IsoWeekDate` or `Iterable` of those types.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; str(IsoWeekDate(\"2025-W01-1\") - 1)\n        '2024-W52-7'\n        &gt;&gt;&gt; tuple(str(iwd) for iwd in IsoWeekDate(\"2025-W01-1\") - (1, 2))\n        ('2024-W52-7', '2024-W52-6')\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\") - IsoWeekDate(\"2024-W52-3\")\n        5\n    \"\"\"\n    return self.__sub__(other)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_compact","title":"to_compact","text":"<pre><code>to_compact() -&gt; str\n</code></pre> <p>Returns as a string in the YYYYWNN format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").to_compact()\n'2025W015'\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_compact(self: Self) -&gt; str:\n    \"\"\"Returns as a string in the YYYYWNN format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-5\").to_compact()\n        '2025W015'\n    \"\"\"\n    return super().to_compact()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_date","title":"to_date","text":"<pre><code>to_date() -&gt; date\n</code></pre> <p>Converts <code>IsoWeekDate</code> to <code>date</code> object.</p> <p>Returns:</p> Type Description <code>date</code> <p><code>date</code> corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").to_date()\ndatetime.date(2024, 12, 30)\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").to_date()\ndatetime.date(2025, 1, 1)\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_date(self: Self) -&gt; date:\n    \"\"\"Converts `IsoWeekDate` to `date` object.\n\n    Returns:\n        `date` corresponding to the `IsoWeekDate`.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").to_date()\n        datetime.date(2024, 12, 30)\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-3\").to_date()\n        datetime.date(2025, 1, 1)\n    \"\"\"\n    return self.to_datetime().date()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime() -&gt; datetime\n</code></pre> <p>Converts <code>IsoWeekDate</code> to <code>datetime</code> object.</p> <p>Returns:</p> Type Description <code>datetime</code> <p><code>datetime</code> corresponding to the <code>IsoWeekDate</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").to_datetime()\ndatetime.datetime(2024, 12, 30, 0, 0)\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_datetime()\ndatetime.datetime(2025, 1, 2, 0, 0)\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_datetime(self: Self) -&gt; datetime:\n    \"\"\"Converts `IsoWeekDate` to `datetime` object.\n\n    Returns:\n        `datetime` corresponding to the `IsoWeekDate`.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-1\").to_datetime()\n        datetime.datetime(2024, 12, 30, 0, 0)\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_datetime()\n        datetime.datetime(2025, 1, 2, 0, 0)\n    \"\"\"\n    return super()._to_datetime(self.value_)\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Returns as a string in the YYYY-WNN-D format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_string()\n'2025-W01-4'\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_string(self: Self) -&gt; str:\n    \"\"\"Returns as a string in the YYYY-WNN-D format.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_string()\n        '2025-W01-4'\n    \"\"\"\n    return super().to_string()\n</code></pre>"},{"location":"api/isoweekdate/#iso_week_date.isoweekdate.IsoWeekDate.to_values","title":"to_values","text":"<pre><code>to_values() -&gt; tuple[int, ...]\n</code></pre> <p>Returns the year, week and weekday as a tuple of integers.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>Tuple of integers representing the year and week.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from iso_week_date import IsoWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_values()\n(2025, 1, 4)\n</code></pre> Source code in <code>iso_week_date/isoweekdate.py</code> <pre><code>def to_values(self: Self) -&gt; tuple[int, ...]:\n    \"\"\"Returns the year, week and weekday as a tuple of integers.\n\n    Returns:\n        Tuple of integers representing the year and week.\n\n    Examples:\n        &gt;&gt;&gt; from iso_week_date import IsoWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; IsoWeekDate(\"2025-W01-4\").to_values()\n        (2025, 1, 4)\n    \"\"\"\n    return super().to_values()\n</code></pre>"},{"location":"api/pandas/","title":"Pandas utils module","text":""},{"location":"api/pandas/#functions","title":"Functions","text":""},{"location":"api/pandas/#iso_week_date.pandas_utils.datetime_to_isoweek","title":"iso_week_date.pandas_utils.datetime_to_isoweek","text":"<pre><code>datetime_to_isoweek(series: Series[Timestamp], offset: OffsetType = 0) -&gt; Series[str]\n</code></pre> <p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[Timestamp]</code> <p>series of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series[str]</code> <p>Series with converted ISO Week values (in format YYYY-WNN)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>series</code> values are not <code>datetime</code>-like</li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import datetime_to_isoweek\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n&gt;&gt;&gt; datetime_to_isoweek(series=s, offset=pd.Timedelta(days=1)).to_list()\n['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweek(series: pd.Series[pd.Timestamp], offset: OffsetType = 0) -&gt; pd.Series[str]:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        series: series of `date` or `datetime` values\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series with converted ISO Week values (in format YYYY-WNN)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `series` values are not `datetime`-like\n            - `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import datetime_to_isoweek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n        &gt;&gt;&gt; datetime_to_isoweek(series=s, offset=pd.Timedelta(days=1)).to_list()\n        ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEK__DATE_FORMAT)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.datetime_to_isoweekdate","title":"iso_week_date.pandas_utils.datetime_to_isoweekdate","text":"<pre><code>datetime_to_isoweekdate(series: Series[Timestamp], offset: OffsetType = 0) -&gt; Series[str]\n</code></pre> <p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[Timestamp]</code> <p>series of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series[str]</code> <p>Series with converted ISO Week date values (in format YYYY-WNN-D)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>series</code> values are not <code>datetime</code>-like</li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import datetime_to_isoweekdate\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n&gt;&gt;&gt; datetime_to_isoweekdate(series=s, offset=pd.Timedelta(days=1)).to_list()\n['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweekdate(series: pd.Series[pd.Timestamp], offset: OffsetType = 0) -&gt; pd.Series[str]:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        series: series of `date` or `datetime` values\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series with converted ISO Week date values (in format YYYY-WNN-D)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `series` values are not `datetime`-like\n            - `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import datetime_to_isoweekdate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n        &gt;&gt;&gt; datetime_to_isoweekdate(series=s, offset=pd.Timedelta(days=1)).to_list()\n        ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEKDATE__DATE_FORMAT)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.isoweek_to_datetime","title":"iso_week_date.pandas_utils.isoweek_to_datetime","text":"<pre><code>isoweek_to_datetime(series: Series[str], offset: OffsetType = 0, weekday: int = 1, *, strict: bool = True) -&gt; Series[Timestamp]\n</code></pre> <p>Converts series of <code>str</code> values in ISO Week format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[str]</code> <p>Series of <code>str</code> values in ISO Week format.</p> required <code>offset</code> <code>OffsetType</code> <p>Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7).</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series[Timestamp]</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import isoweek_to_datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; isoweek_to_datetime(series=s, offset=pd.Timedelta(days=1))\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweek_to_datetime(\n    series: pd.Series[str],\n    offset: OffsetType = 0,\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; pd.Series[pd.Timestamp]:\n    \"\"\"Converts series of `str` values in ISO Week format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        series: Series of `str` values in ISO Week format.\n        offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7).\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `offset` is not of type `pd.Timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import isoweek_to_datetime\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; isoweek_to_datetime(series=s, offset=pd.Timedelta(days=1))\n        0   2022-12-27\n        1   2023-01-03\n        2   2023-01-10\n        dtype: datetime64[ns]\n    \"\"\"\n    if not isinstance(offset, (pd.Timedelta, int)):\n        msg = f\"`offset` must be of type `pd.Timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    if weekday not in range(1, 8):\n        msg = f\"`weekday` value must be an integer between 1 and 7, found {weekday}\"\n        raise ValueError(msg)\n\n    _offset: pd.Timedelta = pd.Timedelta(days=offset) if isinstance(offset, int) else offset\n    errors: ErrorT = \"raise\" if strict else \"coerce\"\n    return pd.to_datetime(series + \"-\" + str(weekday), errors=errors, format=ISOWEEKDATE__DATE_FORMAT) + _offset\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.isoweekdate_to_datetime","title":"iso_week_date.pandas_utils.isoweekdate_to_datetime","text":"<pre><code>isoweekdate_to_datetime(series: Series[str], offset: OffsetType = 0, *, strict: bool = True) -&gt; Series[Timestamp]\n</code></pre> <p>Converts series of <code>str</code> values in ISO Week date format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[str]</code> <p>series of <code>str</code> in ISO Week date format.</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series[Timestamp]</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If one of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pd.Series</code></li> <li><code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import isoweekdate_to_datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; isoweekdate_to_datetime(series=s, offset=pd.Timedelta(days=1))\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweekdate_to_datetime(\n    series: pd.Series[str],\n    offset: OffsetType = 0,\n    *,\n    strict: bool = True,\n) -&gt; pd.Series[pd.Timestamp]:\n    \"\"\"Converts series of `str` values in ISO Week date format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    Arguments:\n        series: series of `str` in ISO Week date format.\n        offset: offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If one of the following condition is met:\n\n            - `series` is not of type `pd.Series`\n            - `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import isoweekdate_to_datetime\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; isoweekdate_to_datetime(series=s, offset=pd.Timedelta(days=1))\n        0   2022-12-27\n        1   2023-01-03\n        2   2023-01-10\n        dtype: datetime64[ns]\n    \"\"\"\n    if not isinstance(offset, (pd.Timedelta, int)):\n        msg = f\"`offset` must be of type `pd.Timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    _offset: pd.Timedelta = pd.Timedelta(days=offset) if isinstance(offset, int) else offset\n    errors: ErrorT = \"raise\" if strict else \"coerce\"\n    return pd.to_datetime(series, errors=errors, format=ISOWEEKDATE__DATE_FORMAT) + _offset\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.is_isoweek_series","title":"iso_week_date.pandas_utils.is_isoweek_series","text":"<pre><code>is_isoweek_series(series: Series[str]) -&gt; bool\n</code></pre> <p>Checks if <code>series</code> contains only values in ISO Week format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[str]</code> <p>series of <code>str</code> values to check against \"YYYY-WNN\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pd.Series</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import is_isoweek_series\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; is_isoweek_series(series=s)\nTrue\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweek_series(series: pd.Series[str]) -&gt; bool:\n    \"\"\"Checks if `series` contains only values in ISO Week format.\n\n    Arguments:\n        series: series of `str` values to check against \"YYYY-WNN\" pattern\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pd.Series`\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import is_isoweek_series\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; is_isoweek_series(series=s)\n        True\n    \"\"\"\n    return _match_series(series, ISOWEEK_PATTERN.pattern)\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.is_isoweekdate_series","title":"iso_week_date.pandas_utils.is_isoweekdate_series","text":"<pre><code>is_isoweekdate_series(series: Series[str]) -&gt; bool\n</code></pre> <p>Checks if <code>series</code> contains only values in ISO Week date format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[str]</code> <p>series of <code>str</code> values to check against \"YYYY-WNN-D\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pd.Series</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import is_isoweekdate_series\n&gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; is_isoweekdate_series(series=s)\nTrue\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweekdate_series(series: pd.Series[str]) -&gt; bool:\n    \"\"\"Checks if `series` contains only values in ISO Week date format.\n\n    Arguments:\n        series: series of `str` values to check against \"YYYY-WNN-D\" pattern\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pd.Series`\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import is_isoweekdate_series\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; is_isoweekdate_series(series=s)\n        True\n    \"\"\"\n    return _match_series(series, ISOWEEKDATE_PATTERN.pattern)\n</code></pre>"},{"location":"api/pandas/#series-extension","title":"Series extension","text":""},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek","title":"iso_week_date.pandas_utils.SeriesIsoWeek","text":"<p>Pandas Series extension that provides methods for working with ISO weeks and dates.</p> <p>Instead of importing and working with single functions from the <code>pandas_utils</code> module, it is possible to import the Series extension class to be able to use the functions as methods on Series objects.</p> <p>To accomplish this, it is enough to load <code>SeriesIsoWeek</code> into scope:</p> <pre><code>from datetime import date\nimport pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\ns = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ns.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[str] | Series[Timestamp]</code> <p>The pandas Series object the extension is attached to.</p> required <p>Attributes:</p> Name Type Description <code>_series</code> <p>The pandas Series object the extension is attached to.</p> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"iwd\")\nclass SeriesIsoWeek:\n    \"\"\"Pandas Series extension that provides methods for working with ISO weeks and dates.\n\n    Instead of importing and working with single functions from the `pandas_utils` module, it is possible to import the\n    Series [extension class](https://pandas.pydata.org/docs/development/extending.html) to be able to use the functions\n    as methods on Series objects.\n\n    To accomplish this, it is enough to load `SeriesIsoWeek` into scope:\n\n    ```python hl_lines=\"3 6\"\n    from datetime import date\n    import pandas as pd\n    from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n    s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n    # ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n    ```\n\n    Arguments:\n        series: The pandas Series object the extension is attached to.\n\n    Attributes:\n        _series: The pandas Series object the extension is attached to.\n    \"\"\"\n\n    def __init__(self: Self, series: pd.Series[str] | pd.Series[pd.Timestamp]) -&gt; None:\n        self._series = series\n\n    def datetime_to_isoweek(self: Self, offset: OffsetType = 0) -&gt; pd.Series[str]:\n        \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week format YYYY-WNN.\n\n        Arguments:\n            offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n                to ISO Week, it can be negative\n\n        Returns:\n            ISO Week pandas series in format YYYY-WNN\n\n        Raises:\n            TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n            &gt;&gt;&gt; s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n            ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n        \"\"\"\n        return datetime_to_isoweek(self._series, offset=offset)  # type: ignore[arg-type]\n\n    def datetime_to_isoweekdate(self: Self, offset: OffsetType = 0) -&gt; pd.Series[str]:\n        \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week date format YYYY-WNN-D.\n\n        Arguments:\n            offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n                to ISO Week, it can be negative\n\n        Returns:\n            ISO Week date pandas series in format YYYY-WNN-D\n\n        Raises:\n            TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n            &gt;&gt;&gt; s.iwd.datetime_to_isoweekdate(offset=pd.Timedelta(days=1)).to_list()\n            ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n        \"\"\"\n        return datetime_to_isoweekdate(self._series, offset=offset)  # type: ignore[arg-type]\n\n    def isoweek_to_datetime(\n        self: Self,\n        offset: OffsetType = 0,\n        weekday: int = 1,\n        *,\n        strict: bool = True,\n    ) -&gt; pd.Series[pd.Timestamp]:\n        \"\"\"Converts series of `str` values in ISO Week format to a series of `datetime` values.\n\n        `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n        `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n        week, 7 is the last one.\n\n        Arguments:\n            offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            weekday: Weekday to use for conversion (1-7).\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series of converted datetime values\n\n        Raises:\n            TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n            ValueError: If `weekday` is not an integer between 1 and 7\n\n        Examples:\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n            &gt;&gt;&gt; s.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n            0   2022-12-27\n            1   2023-01-03\n            2   2023-01-10\n            dtype: datetime64[ns]\n        \"\"\"\n        return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)  # type: ignore[arg-type]\n\n    def isoweekdate_to_datetime(self: Self, offset: OffsetType = 0, *, strict: bool = True) -&gt; pd.Series[pd.Timestamp]:\n        \"\"\"Converts series of `str` values in ISO Week date format to a series of `datetime` values.\n\n        `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n        Arguments:\n            offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series of converted datetime values\n\n        Raises:\n            TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n            ValueError: If `weekday` is not an integer between 1 and 7\n\n        Examples:\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n            &gt;&gt;&gt; s.iwd.isoweekdate_to_datetime(offset=pd.Timedelta(days=1))\n            0   2022-12-27\n            1   2023-01-03\n            2   2023-01-10\n            dtype: datetime64[ns]\n        \"\"\"\n        return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)  # type: ignore[arg-type]\n\n    def is_isoweek(self: Self) -&gt; bool:\n        \"\"\"Checks if series contains only values in ISO Week format.\n\n        Returns:\n            `True` if all values match ISO Week format, `False` otherwise\n\n        Examples:\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n            &gt;&gt;&gt; s.iwd.is_isoweek()\n            True\n        \"\"\"\n        return is_isoweek_series(self._series)  # type: ignore[arg-type]\n\n    def is_isoweekdate(self: Self) -&gt; bool:\n        \"\"\"Checks if series contains only values in ISO Week date format.\n\n        Returns:\n            `True` if all values match ISO Week date format, `False` otherwise\n\n        Examples:\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n            &gt;&gt;&gt; s.iwd.is_isoweekdate()\n            True\n        \"\"\"\n        return is_isoweekdate_series(self._series)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.datetime_to_isoweek","title":"datetime_to_isoweek","text":"<pre><code>datetime_to_isoweek(offset: OffsetType = 0) -&gt; Series[str]\n</code></pre> <p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series[str]</code> <p>ISO Week pandas series in format YYYY-WNN</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If series values are not <code>datetime</code>, or if <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n&gt;&gt;&gt; s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweek(self: Self, offset: OffsetType = 0) -&gt; pd.Series[str]:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n            to ISO Week, it can be negative\n\n    Returns:\n        ISO Week pandas series in format YYYY-WNN\n\n    Raises:\n        TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n        &gt;&gt;&gt; s.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n        ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n    \"\"\"\n    return datetime_to_isoweek(self._series, offset=offset)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.datetime_to_isoweekdate","title":"datetime_to_isoweekdate","text":"<pre><code>datetime_to_isoweekdate(offset: OffsetType = 0) -&gt; Series[str]\n</code></pre> <p>Converts series of <code>date</code> or <code>datetime</code> values to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>pd.Timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>0</code> <p>Returns:</p> Type Description <code>Series[str]</code> <p>ISO Week date pandas series in format YYYY-WNN-D</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If series values are not <code>datetime</code>, or if <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n&gt;&gt;&gt; s.iwd.datetime_to_isoweekdate(offset=pd.Timedelta(days=1)).to_list()\n['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def datetime_to_isoweekdate(self: Self, offset: OffsetType = 0) -&gt; pd.Series[str]:\n    \"\"\"Converts series of `date` or `datetime` values to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        offset: offset in days or `pd.Timedelta`. It represents how many days to add to the date before converting\n            to ISO Week, it can be negative\n\n    Returns:\n        ISO Week date pandas series in format YYYY-WNN-D\n\n    Raises:\n        TypeError: If series values are not `datetime`, or if `offset` is not of type `pd.Timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\n        &gt;&gt;&gt; s.iwd.datetime_to_isoweekdate(offset=pd.Timedelta(days=1)).to_list()\n        ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n    \"\"\"\n    return datetime_to_isoweekdate(self._series, offset=offset)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.is_isoweek","title":"is_isoweek","text":"<pre><code>is_isoweek() -&gt; bool\n</code></pre> <p>Checks if series contains only values in ISO Week format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; s.iwd.is_isoweek()\nTrue\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweek(self: Self) -&gt; bool:\n    \"\"\"Checks if series contains only values in ISO Week format.\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; s.iwd.is_isoweek()\n        True\n    \"\"\"\n    return is_isoweek_series(self._series)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.is_isoweekdate","title":"is_isoweekdate","text":"<pre><code>is_isoweekdate() -&gt; bool\n</code></pre> <p>Checks if series contains only values in ISO Week date format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; s.iwd.is_isoweekdate()\nTrue\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def is_isoweekdate(self: Self) -&gt; bool:\n    \"\"\"Checks if series contains only values in ISO Week date format.\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; s.iwd.is_isoweekdate()\n        True\n    \"\"\"\n    return is_isoweekdate_series(self._series)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.isoweek_to_datetime","title":"isoweek_to_datetime","text":"<pre><code>isoweek_to_datetime(offset: OffsetType = 0, weekday: int = 1, *, strict: bool = True) -&gt; Series[Timestamp]\n</code></pre> <p>Converts series of <code>str</code> values in ISO Week format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7).</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series[Timestamp]</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; s.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweek_to_datetime(\n    self: Self,\n    offset: OffsetType = 0,\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; pd.Series[pd.Timestamp]:\n    \"\"\"Converts series of `str` values in ISO Week format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7).\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; s.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n        0   2022-12-27\n        1   2023-01-03\n        2   2023-01-10\n        dtype: datetime64[ns]\n    \"\"\"\n    return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/pandas/#iso_week_date.pandas_utils.SeriesIsoWeek.isoweekdate_to_datetime","title":"isoweekdate_to_datetime","text":"<pre><code>isoweekdate_to_datetime(offset: OffsetType = 0, *, strict: bool = True) -&gt; Series[Timestamp]\n</code></pre> <p>Converts series of <code>str</code> values in ISO Week date format to a series of <code>datetime</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to datetime and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>0</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series[Timestamp]</code> <p>Series of converted datetime values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>pd.Timedelta</code> or <code>int</code></p> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; s.iwd.isoweekdate_to_datetime(offset=pd.Timedelta(days=1))\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n</code></pre> Source code in <code>iso_week_date/pandas_utils.py</code> <pre><code>def isoweekdate_to_datetime(self: Self, offset: OffsetType = 0, *, strict: bool = True) -&gt; pd.Series[pd.Timestamp]:\n    \"\"\"Converts series of `str` values in ISO Week date format to a series of `datetime` values.\n\n    `offset` represents how many days to add to the date before converting to datetime and it can be negative.\n\n    Arguments:\n        offset: Offset in days or pd.Timedelta. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series of converted datetime values\n\n    Raises:\n        TypeError: If `offset` is not of type `pd.Timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pd.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; s.iwd.isoweekdate_to_datetime(offset=pd.Timedelta(days=1))\n        0   2022-12-27\n        1   2023-01-03\n        2   2023-01-10\n        dtype: datetime64[ns]\n    \"\"\"\n    return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/polars/","title":"Polars utils module","text":""},{"location":"api/polars/#functions","title":"Functions","text":""},{"location":"api/polars/#iso_week_date.polars_utils.datetime_to_isoweek","title":"iso_week_date.polars_utils.datetime_to_isoweek","text":"<pre><code>datetime_to_isoweek(series: ExprOrSeries, offset: OffsetType = timedelta(days=0)) -&gt; ExprOrSeries\n</code></pre> <p>Converts <code>date(time)</code> <code>series/expr</code> to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>series or expr of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(days=0)</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import datetime_to_isoweek\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n&gt;&gt;&gt; datetime_to_isoweek(s, offset=timedelta(days=1))\nshape: (5,)\nSeries: 'literal' [str]\n[\n   \"2022-W52\"\n   \"2022-W52\"\n   \"2023-W01\"\n   \"2023-W01\"\n   \"2023-W01\"\n]\n&gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n&gt;&gt;&gt; df.select(datetime_to_isoweek(pl.col(\"date\"), offset=1))\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 date     \u2502\n\u2502 ---      \u2502\n\u2502 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2022-W52 \u2502\n\u2502 2022-W52 \u2502\n\u2502 2023-W01 \u2502\n\u2502 2023-W01 \u2502\n\u2502 2023-W01 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweek(series: ExprOrSeries, offset: OffsetType = timedelta(days=0)) -&gt; ExprOrSeries:\n    \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        series: series or expr of `date` or `datetime` values\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to ISO\n            Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date, timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import datetime_to_isoweek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n        &gt;&gt;&gt; datetime_to_isoweek(s, offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (5,)\n        Series: 'literal' [str]\n        [\n           \"2022-W52\"\n           \"2022-W52\"\n           \"2023-W01\"\n           \"2023-W01\"\n           \"2023-W01\"\n        ]\n        &gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n        &gt;&gt;&gt; df.select(datetime_to_isoweek(pl.col(\"date\"), offset=1))\n        shape: (5, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 date     \u2502\n        \u2502 ---      \u2502\n        \u2502 str      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2022-W52 \u2502\n        \u2502 2022-W52 \u2502\n        \u2502 2023-W01 \u2502\n        \u2502 2023-W01 \u2502\n        \u2502 2023-W01 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEK__DATE_FORMAT)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.datetime_to_isoweekdate","title":"iso_week_date.polars_utils.datetime_to_isoweekdate","text":"<pre><code>datetime_to_isoweekdate(series: ExprOrSeries, offset: OffsetType = timedelta(days=0)) -&gt; ExprOrSeries\n</code></pre> <p>Converts <code>date(time)</code> <code>series/expr</code>  to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>series or expr of <code>date</code> or <code>datetime</code> values</p> required <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(days=0)</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN-D)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import datetime_to_isoweekdate\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n&gt;&gt;&gt; datetime_to_isoweekdate(s, offset=timedelta(days=1))\nshape: (5,)\nSeries: 'literal' [str]\n[\n   \"2022-W52-6\"\n   \"2022-W52-7\"\n   \"2023-W01-1\"\n   \"2023-W01-2\"\n   \"2023-W01-3\"\n]\n&gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n&gt;&gt;&gt; df.select(datetime_to_isoweekdate(pl.col(\"date\"), offset=1))\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 date       \u2502\n\u2502 ---        \u2502\n\u2502 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2022-W52-6 \u2502\n\u2502 2022-W52-7 \u2502\n\u2502 2023-W01-1 \u2502\n\u2502 2023-W01-2 \u2502\n\u2502 2023-W01-3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweekdate(series: ExprOrSeries, offset: OffsetType = timedelta(days=0)) -&gt; ExprOrSeries:\n    \"\"\"Converts `date(time)` `series/expr`  to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        series: series or expr of `date` or `datetime` values\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to ISO\n            Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN-D)\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date, timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import datetime_to_isoweekdate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n        &gt;&gt;&gt; datetime_to_isoweekdate(s, offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (5,)\n        Series: 'literal' [str]\n        [\n           \"2022-W52-6\"\n           \"2022-W52-7\"\n           \"2023-W01-1\"\n           \"2023-W01-2\"\n           \"2023-W01-3\"\n        ]\n        &gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n        &gt;&gt;&gt; df.select(datetime_to_isoweekdate(pl.col(\"date\"), offset=1))\n        shape: (5, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 date       \u2502\n        \u2502 ---        \u2502\n        \u2502 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2022-W52-6 \u2502\n        \u2502 2022-W52-7 \u2502\n        \u2502 2023-W01-1 \u2502\n        \u2502 2023-W01-2 \u2502\n        \u2502 2023-W01-3 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return _datetime_to_format(series, offset, ISOWEEKDATE__DATE_FORMAT)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.isoweek_to_datetime","title":"iso_week_date.polars_utils.isoweek_to_datetime","text":"<pre><code>isoweek_to_datetime(series: ExprOrSeries, offset: OffsetType = timedelta(days=0), weekday: int = 1, *, strict: bool = True) -&gt; ExprOrSeries\n</code></pre> <p>Converts series or expr of <code>str</code> values in ISO Week format YYYY-WNN to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>Series or Expr of <code>str</code> values in ISO Week format.</p> required <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>timedelta(days=0)</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7)</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import isoweek_to_datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; isoweek_to_datetime(series=s, offset=timedelta(days=1))\nshape: (3,)\nSeries: '' [date]\n[\n    2022-12-27\n    2023-01-03\n    2023-01-10\n]\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweek_to_datetime(\n    series: ExprOrSeries,\n    offset: OffsetType = timedelta(days=0),\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; ExprOrSeries:\n    \"\"\"Converts series or expr of `str` values in ISO Week format YYYY-WNN to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        series: Series or Expr of `str` values in ISO Week format.\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7)\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import isoweek_to_datetime\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; isoweek_to_datetime(series=s, offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (3,)\n        Series: '' [date]\n        [\n            2022-12-27\n            2023-01-03\n            2023-01-10\n        ]\n    \"\"\"\n    if not isinstance(offset, (timedelta, int)):\n        msg = f\"`offset` must be of type `timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    if weekday not in range(1, 8):\n        msg = f\"`weekday` value must be an integer between 1 and 7, found {weekday}\"\n        raise ValueError(msg)\n\n    _offset = timedelta(days=offset) if isinstance(offset, int) else offset\n\n    return (series + f\"-{weekday}\").str.strptime(pl.Date, ISOWEEKDATE__DATE_FORMAT, strict=strict) + _offset\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.isoweekdate_to_datetime","title":"iso_week_date.polars_utils.isoweekdate_to_datetime","text":"<pre><code>isoweekdate_to_datetime(series: ExprOrSeries, offset: OffsetType = timedelta(days=0), *, strict: bool = True) -&gt; ExprOrSeries\n</code></pre> <p>Converts <code>series/expr</code> of values in ISO Week date format YYYY-WNN-D to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>Series or Expr of <code>str</code> values in ISO Week date format</p> required <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative</p> <code>timedelta(days=0)</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the following condition is met:</p> <ul> <li><code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></li> <li><code>offset</code> is not of type <code>timedelta</code> or <code>int</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import isoweekdate_to_datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; isoweekdate_to_datetime(series=s, offset=timedelta(days=1))\nshape: (3,)\nSeries: '' [date]\n[\n    2023-01-02\n    2023-01-03\n    2023-01-10\n]\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweekdate_to_datetime(\n    series: ExprOrSeries,\n    offset: OffsetType = timedelta(days=0),\n    *,\n    strict: bool = True,\n) -&gt; ExprOrSeries:\n    \"\"\"Converts `series/expr` of values in ISO Week date format YYYY-WNN-D to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    Arguments:\n        series: Series or Expr of `str` values in ISO Week date format\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If any of the following condition is met:\n\n            - `series` is not of type `pl.Series` or `pl.Expr`\n            - `offset` is not of type `timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import isoweekdate_to_datetime\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; isoweekdate_to_datetime(series=s, offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (3,)\n        Series: '' [date]\n        [\n            2023-01-02\n            2023-01-03\n            2023-01-10\n        ]\n    \"\"\"\n    if not isinstance(offset, (timedelta, int)):\n        msg = f\"`offset` must be of type `timedelta` or `int`, found {type(offset)}\"\n        raise TypeError(msg)\n\n    _offset = timedelta(days=offset) if isinstance(offset, int) else offset\n\n    return series.str.strptime(pl.Date, ISOWEEKDATE__DATE_FORMAT, strict=strict) + _offset\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.is_isoweek_series","title":"iso_week_date.polars_utils.is_isoweek_series","text":"<pre><code>is_isoweek_series(series: ExprOrSeries) -&gt; bool\n</code></pre> <p>Checks if a series or expr contains only values in ISO Week format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>series or expr of <code>str</code> values to check against \"YYYY-WNN\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import is_isoweek_series\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; is_isoweek_series(s)\nTrue\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweek_series(series: ExprOrSeries) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week format.\n\n    Arguments:\n        series: series or expr of `str` values to check against \"YYYY-WNN\" pattern\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pl.Series` or `pl.Expr`\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import is_isoweek_series\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; is_isoweek_series(s)\n        True\n    \"\"\"\n    return _match_series(series, ISOWEEK_PATTERN.pattern)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.is_isoweekdate_series","title":"iso_week_date.polars_utils.is_isoweekdate_series","text":"<pre><code>is_isoweekdate_series(series: ExprOrSeries) -&gt; bool\n</code></pre> <p>Checks if a series or expr contains only values in ISO Week date format.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>series or expr of <code>str</code> values to check against \"YYYY-WNN-D\" pattern</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>series</code> is not of type <code>pl.Series</code> or <code>pl.Expr</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import is_isoweekdate_series\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; is_isoweekdate_series(series=s)\nTrue\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweekdate_series(series: ExprOrSeries) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week date format.\n\n    Arguments:\n        series: series or expr of `str` values to check against \"YYYY-WNN-D\" pattern\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Raises:\n        TypeError: If `series` is not of type `pl.Series` or `pl.Expr`\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import is_isoweekdate_series\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; is_isoweekdate_series(series=s)\n        True\n    \"\"\"\n    return _match_series(series, ISOWEEKDATE_PATTERN.pattern)\n</code></pre>"},{"location":"api/polars/#series-extension","title":"Series extension","text":""},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek","title":"iso_week_date.polars_utils.SeriesIsoWeek","text":"<p>               Bases: <code>Generic[ExprOrSeries]</code></p> <p>Polars Series and Expr extension that provides methods for working with ISO weeks and dates.</p> <p>Instead of importing and working with single functions from the <code>polars_utils</code> module, it is possible to import the Series and Expr extension class to be able to use the functions as methods on Series and Expr objects.</p> <p>To accomplish this, it is enough to load <code>SeriesIsoWeek</code> into scope:</p> <pre><code>from datetime import date, timedelta\nimport polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\ns = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ns.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\ndf = pl.DataFrame({\"date\": s})\ndf.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ExprOrSeries</code> <p>ExprOrSerieshe pandas Series object the extension is attached to.</p> required <p>Attributes:</p> Name Type Description <code>_series</code> <code>ExprOrSeries</code> <p>ExprOrSerieshe pandas Series object the extension is attached to.</p> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>@pl.api.register_series_namespace(\"iwd\")\n@pl.api.register_expr_namespace(\"iwd\")\nclass SeriesIsoWeek(Generic[ExprOrSeries]):\n    \"\"\"Polars Series and Expr extension that provides methods for working with ISO weeks and dates.\n\n    Instead of importing and working with single functions from the `polars_utils` module, it is possible to import the\n    Series and Expr [extension class](https://pola-rs.github.io/polars/py-polars/html/reference/api.html) to be able to\n    use the functions as methods on Series and Expr objects.\n\n    To accomplish this, it is enough to load `SeriesIsoWeek` into scope:\n\n    ```python hl_lines=\"3 6 9\"\n    from datetime import date, timedelta\n    import polars as pl\n    from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n\n    s = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\n    s.iwd.datetime_to_isoweek(offset=timedelta(days=1))\n\n    df = pl.DataFrame({\"date\": s})\n    df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n    ```\n\n    Arguments:\n        series: ExprOrSerieshe pandas Series object the extension is attached to.\n\n    Attributes:\n        _series: ExprOrSerieshe pandas Series object the extension is attached to.\n    \"\"\"\n\n    def __init__(self: Self, series: ExprOrSeries) -&gt; None:\n        self._series: ExprOrSeries = series\n\n    def datetime_to_isoweek(self: Self, offset: OffsetType = timedelta(0)) -&gt; ExprOrSeries:\n        \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week format YYYY-WNN.\n\n        Arguments:\n            offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                ISO Week, it can be negative\n\n        Returns:\n            Series or Expr with converted ISO Week values (in format YYYY-WNN)\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date, timedelta\n            &gt;&gt;&gt; import polars as pl\n            &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n            &gt;&gt;&gt; s.iwd.datetime_to_isoweek(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n            shape: (5,)\n            Series: 'literal' [str]\n            [\n                \"2022-W52\"\n                \"2022-W52\"\n                \"2023-W01\"\n                \"2023-W01\"\n                \"2023-W01\"\n            ]\n            &gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n            &gt;&gt;&gt; df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n            shape: (5, 1)\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 date     \u2502\n            \u2502 ---      \u2502\n            \u2502 str      \u2502\n            \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n            \u2502 2022-W52 \u2502\n            \u2502 2022-W52 \u2502\n            \u2502 2023-W01 \u2502\n            \u2502 2023-W01 \u2502\n            \u2502 2023-W01 \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n        return datetime_to_isoweek(self._series, offset=offset)\n\n    def datetime_to_isoweekdate(self: Self, offset: OffsetType = timedelta(0)) -&gt; ExprOrSeries:\n        \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week date format YYYY-WNN-D.\n\n        Arguments:\n            offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                ISO Week, it can be negative\n\n        Returns:\n            Series or Expr with converted ISO Week values (in format YYYY-WNN-D)\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n\n        Examples:\n            &gt;&gt;&gt; from datetime import date, timedelta\n            &gt;&gt;&gt; import polars as pl\n            &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n            &gt;&gt;&gt; s.iwd.datetime_to_isoweekdate(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n            shape: (5,)\n            Series: 'literal' [str]\n            [\n                \"2022-W52-6\"\n                \"2022-W52-7\"\n                \"2023-W01-1\"\n                \"2023-W01-2\"\n                \"2023-W01-3\"\n            ]\n            &gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n            &gt;&gt;&gt; df.select(pl.col(\"date\").iwd.datetime_to_isoweekdate(offset=1))\n            shape: (5, 1)\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 date       \u2502\n            \u2502 ---        \u2502\n            \u2502 str        \u2502\n            \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n            \u2502 2022-W52-6 \u2502\n            \u2502 2022-W52-7 \u2502\n            \u2502 2023-W01-1 \u2502\n            \u2502 2023-W01-2 \u2502\n            \u2502 2023-W01-3 \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n        return datetime_to_isoweekdate(self._series, offset=offset)\n\n    def isoweek_to_datetime(\n        self: Self,\n        offset: OffsetType = timedelta(0),\n        weekday: int = 1,\n        *,\n        strict: bool = True,\n    ) -&gt; ExprOrSeries:\n        \"\"\"Converts series or expr of `str` values in ISO Week format YYYY-WNN to a series or expr of `pl.Date` values.\n\n        `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n        `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n        week, 7 is the last one.\n\n        Arguments:\n            offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            weekday: Weekday to use for conversion (1-7).\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series or Expr of converted date values\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n            ValueError: If `weekday` is not an integer between 1 and 7\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; import polars as pl\n            &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n            &gt;&gt;&gt; s.iwd.isoweek_to_datetime(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n            shape: (3,)\n            Series: '' [date]\n            [\n                2022-12-27\n                2023-01-03\n                2023-01-10\n            ]\n        \"\"\"\n        return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)\n\n    def isoweekdate_to_datetime(self: Self, offset: OffsetType = timedelta(0), *, strict: bool = True) -&gt; ExprOrSeries:\n        \"\"\"Converts `str` series or expr of ISO Week date format YYYY-WNN-D to a series or expr of `pl.Date` values.\n\n        `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n        Arguments:\n            offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n                IsoWeek, it can be negative.\n            strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n        Returns:\n            Series or Expr of converted date values\n\n        Raises:\n            TypeError: If `offset` is not of type `timedelta` or `int`\n\n        Examples:\n            &gt;&gt;&gt; from datetime import timedelta\n            &gt;&gt;&gt; import polars as pl\n            &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n            &gt;&gt;&gt; s.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n            shape: (3,)\n            Series: '' [date]\n            [\n                2023-01-02\n                2023-01-03\n                2023-01-10\n            ]\n        \"\"\"\n        return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)\n\n    def is_isoweek(self: Self) -&gt; bool:\n        \"\"\"Checks if a series or expr contains only values in ISO Week format.\n\n        Returns:\n            `True` if all values match ISO Week format, `False` otherwise\n\n        Examples:\n            &gt;&gt;&gt; import polars as pl\n            &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n            &gt;&gt;&gt; s.iwd.is_isoweek()\n            True\n        \"\"\"\n        return is_isoweek_series(self._series)\n\n    def is_isoweekdate(self: Self) -&gt; bool:\n        \"\"\"Checks if a series or expr contains only values in ISO Week date format.\n\n        Returns:\n            `True` if all values match ISO Week date format, `False` otherwise\n\n        Examples:\n            &gt;&gt;&gt; import polars as pl\n            &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n            &gt;&gt;&gt; s.iwd.is_isoweekdate()\n            True\n        \"\"\"\n        return is_isoweekdate_series(self._series)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.datetime_to_isoweek","title":"datetime_to_isoweek","text":"<pre><code>datetime_to_isoweek(offset: OffsetType = timedelta(0)) -&gt; ExprOrSeries\n</code></pre> <p>Converts <code>date(time)</code> <code>series/expr</code> to <code>str</code> values representing ISO Week format YYYY-WNN.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(0)</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n&gt;&gt;&gt; s.iwd.datetime_to_isoweek(offset=timedelta(days=1))\nshape: (5,)\nSeries: 'literal' [str]\n[\n    \"2022-W52\"\n    \"2022-W52\"\n    \"2023-W01\"\n    \"2023-W01\"\n    \"2023-W01\"\n]\n&gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n&gt;&gt;&gt; df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 date     \u2502\n\u2502 ---      \u2502\n\u2502 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2022-W52 \u2502\n\u2502 2022-W52 \u2502\n\u2502 2023-W01 \u2502\n\u2502 2023-W01 \u2502\n\u2502 2023-W01 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweek(self: Self, offset: OffsetType = timedelta(0)) -&gt; ExprOrSeries:\n    \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week format YYYY-WNN.\n\n    Arguments:\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN)\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date, timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n        &gt;&gt;&gt; s.iwd.datetime_to_isoweek(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (5,)\n        Series: 'literal' [str]\n        [\n            \"2022-W52\"\n            \"2022-W52\"\n            \"2023-W01\"\n            \"2023-W01\"\n            \"2023-W01\"\n        ]\n        &gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n        &gt;&gt;&gt; df.select(pl.col(\"date\").iwd.datetime_to_isoweek(offset=1))\n        shape: (5, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 date     \u2502\n        \u2502 ---      \u2502\n        \u2502 str      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2022-W52 \u2502\n        \u2502 2022-W52 \u2502\n        \u2502 2023-W01 \u2502\n        \u2502 2023-W01 \u2502\n        \u2502 2023-W01 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return datetime_to_isoweek(self._series, offset=offset)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.datetime_to_isoweekdate","title":"datetime_to_isoweekdate","text":"<pre><code>datetime_to_isoweekdate(offset: OffsetType = timedelta(0)) -&gt; ExprOrSeries\n</code></pre> <p>Converts <code>date(time)</code> <code>series/expr</code> to <code>str</code> values representing ISO Week date format YYYY-WNN-D.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to ISO Week, it can be negative</p> <code>timedelta(0)</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr with converted ISO Week values (in format YYYY-WNN-D)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n&gt;&gt;&gt; s.iwd.datetime_to_isoweekdate(offset=timedelta(days=1))\nshape: (5,)\nSeries: 'literal' [str]\n[\n    \"2022-W52-6\"\n    \"2022-W52-7\"\n    \"2023-W01-1\"\n    \"2023-W01-2\"\n    \"2023-W01-3\"\n]\n&gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n&gt;&gt;&gt; df.select(pl.col(\"date\").iwd.datetime_to_isoweekdate(offset=1))\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 date       \u2502\n\u2502 ---        \u2502\n\u2502 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2022-W52-6 \u2502\n\u2502 2022-W52-7 \u2502\n\u2502 2023-W01-1 \u2502\n\u2502 2023-W01-2 \u2502\n\u2502 2023-W01-3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def datetime_to_isoweekdate(self: Self, offset: OffsetType = timedelta(0)) -&gt; ExprOrSeries:\n    \"\"\"Converts `date(time)` `series/expr` to `str` values representing ISO Week date format YYYY-WNN-D.\n\n    Arguments:\n        offset: offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            ISO Week, it can be negative\n\n    Returns:\n        Series or Expr with converted ISO Week values (in format YYYY-WNN-D)\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import date, timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.date_range(date(2023, 1, 1), date(2023, 1, 5), interval=\"1d\", eager=True)\n        &gt;&gt;&gt; s.iwd.datetime_to_isoweekdate(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (5,)\n        Series: 'literal' [str]\n        [\n            \"2022-W52-6\"\n            \"2022-W52-7\"\n            \"2023-W01-1\"\n            \"2023-W01-2\"\n            \"2023-W01-3\"\n        ]\n        &gt;&gt;&gt; df = pl.DataFrame({\"date\": s})\n        &gt;&gt;&gt; df.select(pl.col(\"date\").iwd.datetime_to_isoweekdate(offset=1))\n        shape: (5, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 date       \u2502\n        \u2502 ---        \u2502\n        \u2502 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2022-W52-6 \u2502\n        \u2502 2022-W52-7 \u2502\n        \u2502 2023-W01-1 \u2502\n        \u2502 2023-W01-2 \u2502\n        \u2502 2023-W01-3 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return datetime_to_isoweekdate(self._series, offset=offset)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.is_isoweek","title":"is_isoweek","text":"<pre><code>is_isoweek() -&gt; bool\n</code></pre> <p>Checks if a series or expr contains only values in ISO Week format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week format, <code>False</code> otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; s.iwd.is_isoweek()\nTrue\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweek(self: Self) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week format.\n\n    Returns:\n        `True` if all values match ISO Week format, `False` otherwise\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; s.iwd.is_isoweek()\n        True\n    \"\"\"\n    return is_isoweek_series(self._series)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.is_isoweekdate","title":"is_isoweekdate","text":"<pre><code>is_isoweekdate() -&gt; bool\n</code></pre> <p>Checks if a series or expr contains only values in ISO Week date format.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values match ISO Week date format, <code>False</code> otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; s.iwd.is_isoweekdate()\nTrue\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def is_isoweekdate(self: Self) -&gt; bool:\n    \"\"\"Checks if a series or expr contains only values in ISO Week date format.\n\n    Returns:\n        `True` if all values match ISO Week date format, `False` otherwise\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52-1\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; s.iwd.is_isoweekdate()\n        True\n    \"\"\"\n    return is_isoweekdate_series(self._series)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.isoweek_to_datetime","title":"isoweek_to_datetime","text":"<pre><code>isoweek_to_datetime(offset: OffsetType = timedelta(0), weekday: int = 1, *, strict: bool = True) -&gt; ExprOrSeries\n</code></pre> <p>Converts series or expr of <code>str</code> values in ISO Week format YYYY-WNN to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p><code>weekday</code> represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the week, 7 is the last one.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>timedelta(0)</code> <code>weekday</code> <code>int</code> <p>Weekday to use for conversion (1-7).</p> <code>1</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <code>ValueError</code> <p>If <code>weekday</code> is not an integer between 1 and 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n&gt;&gt;&gt; s.iwd.isoweek_to_datetime(offset=timedelta(days=1))\nshape: (3,)\nSeries: '' [date]\n[\n    2022-12-27\n    2023-01-03\n    2023-01-10\n]\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweek_to_datetime(\n    self: Self,\n    offset: OffsetType = timedelta(0),\n    weekday: int = 1,\n    *,\n    strict: bool = True,\n) -&gt; ExprOrSeries:\n    \"\"\"Converts series or expr of `str` values in ISO Week format YYYY-WNN to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    `weekday` represents the weekday to use for conversion in ISO Week format (1-7), where 1 is the first day of the\n    week, 7 is the last one.\n\n    Arguments:\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        weekday: Weekday to use for conversion (1-7).\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n        ValueError: If `weekday` is not an integer between 1 and 7\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\n        &gt;&gt;&gt; s.iwd.isoweek_to_datetime(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (3,)\n        Series: '' [date]\n        [\n            2022-12-27\n            2023-01-03\n            2023-01-10\n        ]\n    \"\"\"\n    return isoweek_to_datetime(self._series, offset=offset, weekday=weekday, strict=strict)\n</code></pre>"},{"location":"api/polars/#iso_week_date.polars_utils.SeriesIsoWeek.isoweekdate_to_datetime","title":"isoweekdate_to_datetime","text":"<pre><code>isoweekdate_to_datetime(offset: OffsetType = timedelta(0), *, strict: bool = True) -&gt; ExprOrSeries\n</code></pre> <p>Converts <code>str</code> series or expr of ISO Week date format YYYY-WNN-D to a series or expr of <code>pl.Date</code> values.</p> <p><code>offset</code> represents how many days to add to the date before converting to <code>pl.Date</code>, and it can be negative.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>OffsetType</code> <p>Offset in days or <code>timedelta</code>. It represents how many days to add to the date before converting to IsoWeek, it can be negative.</p> <code>timedelta(0)</code> <code>strict</code> <code>bool</code> <p>Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.</p> <code>True</code> <p>Returns:</p> Type Description <code>ExprOrSeries</code> <p>Series or Expr of converted date values</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>offset</code> is not of type <code>timedelta</code> or <code>int</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n&gt;&gt;&gt; s.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))\nshape: (3,)\nSeries: '' [date]\n[\n    2023-01-02\n    2023-01-03\n    2023-01-10\n]\n</code></pre> Source code in <code>iso_week_date/polars_utils.py</code> <pre><code>def isoweekdate_to_datetime(self: Self, offset: OffsetType = timedelta(0), *, strict: bool = True) -&gt; ExprOrSeries:\n    \"\"\"Converts `str` series or expr of ISO Week date format YYYY-WNN-D to a series or expr of `pl.Date` values.\n\n    `offset` represents how many days to add to the date before converting to `pl.Date`, and it can be negative.\n\n    Arguments:\n        offset: Offset in days or `timedelta`. It represents how many days to add to the date before converting to\n            IsoWeek, it can be negative.\n        strict: Raise an error if the values cannot be converted to datetime. Otherwise mask out with a null value.\n\n    Returns:\n        Series or Expr of converted date values\n\n    Raises:\n        TypeError: If `offset` is not of type `timedelta` or `int`\n\n    Examples:\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s = pl.Series([\"2022-W52-7\", \"2023-W01-1\", \"2023-W02-1\"])\n        &gt;&gt;&gt; s.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))  # doctest: +NORMALIZE_WHITESPACE\n        shape: (3,)\n        Series: '' [date]\n        [\n            2023-01-02\n            2023-01-03\n            2023-01-10\n        ]\n    \"\"\"\n    return isoweekdate_to_datetime(self._series, offset=offset, strict=strict)\n</code></pre>"},{"location":"api/pydantic/","title":"Pydantic Types","text":"<p>Pydantic model compatible types, implementation follows pydantic documentation at: Customizing validation with <code>__get_pydantic_core_schema__</code> and it requires <code>pydantic&gt;=2.4.0</code>.</p>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeek","title":"iso_week_date.pydantic.T_ISOWeek","text":"<p>               Bases: <code>str</code></p> <p>T_ISOWeek parses iso week in the ISO 8601 format.</p> <p>New in version 1.2.0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt; from iso_week_date.pydantic import T_ISOWeek\n&gt;&gt;&gt;\n&gt;&gt;&gt; class Model(BaseModel):\n...     isoweek: T_ISOWeek\n</code></pre> <pre><code>&gt;&gt;&gt; model = Model(isoweek=\"2024-W01\")\n&gt;&gt;&gt; model\nModel(isoweek='2024-W01')\n</code></pre> <pre><code>&gt;&gt;&gt; _ = Model(isoweek=\"2024-W53\")\nTraceback (most recent call last):\n...\npydantic_core._pydantic_core.ValidationError: 1 validation error for Model\nisoweek\n  Invalid week number. Year 2024 has only 52 weeks. [type=T_ISOWeek, input_value='2024-W53', input_type=str]\n</code></pre> <pre><code>&gt;&gt;&gt; _ = Model(isoweek=\"abc\")\nTraceback (most recent call last):\n...\npydantic_core._pydantic_core.ValidationError: 1 validation error for Model\nisoweek\n  Invalid iso week pattern [type=T_ISOWeek, input_value='abc', input_type=str]\n</code></pre> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>class T_ISOWeek(str):  # noqa: N801\n    \"\"\"T_ISOWeek parses iso week in the [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date) format.\n\n    !!! info \"New in version 1.2.0\"\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt; from iso_week_date.pydantic import T_ISOWeek\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Model(BaseModel):\n        ...     isoweek: T_ISOWeek\n\n        &gt;&gt;&gt; model = Model(isoweek=\"2024-W01\")\n        &gt;&gt;&gt; model\n        Model(isoweek='2024-W01')\n\n        &gt;&gt;&gt; _ = Model(isoweek=\"2024-W53\")\n        Traceback (most recent call last):\n        ...\n        pydantic_core._pydantic_core.ValidationError: 1 validation error for Model\n        isoweek\n          Invalid week number. Year 2024 has only 52 weeks. [type=T_ISOWeek, input_value='2024-W53', input_type=str]\n\n        &gt;&gt;&gt; _ = Model(isoweek=\"abc\")\n        Traceback (most recent call last):\n        ...\n        pydantic_core._pydantic_core.ValidationError: 1 validation error for Model\n        isoweek\n          Invalid iso week pattern [type=T_ISOWeek, input_value='abc', input_type=str]\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: type[Self],\n        source: type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Return a Pydantic CoreSchema with the IsoWeek pattern validation.\n\n        Arguments:\n            source: The source type to be converted.\n            handler: The handler to get the CoreSchema.\n\n        Returns:\n            A Pydantic CoreSchema with the IsoWeek pattern validation.\n        \"\"\"\n        return core_schema.with_info_before_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n        )\n\n    @classmethod\n    def _validate(cls: type[Self], /, __input_value: str, _: core_schema.ValidationInfo) -&gt; Self:\n        \"\"\"Validates iso week string format against ISOWEEK_PATTERN.\"\"\"\n        _match = ISOWEEK_PATTERN.match(__input_value)\n\n        if not _match:\n            raise PydanticCustomError(\"T_ISOWeek\", \"Invalid iso week pattern\")  # noqa: EM101\n\n        year, week = int(_match.group(1)), int(_match.group(2)[1:])\n\n        if (weeks_in_year := weeks_of_year(year)) &lt; week:\n            raise PydanticCustomError(\n                \"T_ISOWeek\",  # noqa: EM101\n                \"Invalid week number. Year {year} has only {weeks_in_year} weeks.\",\n                {\"year\": year, \"weeks_in_year\": weeks_in_year},\n            )\n\n        return cls(__input_value)\n</code></pre>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeek.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[Any], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> <p>Return a Pydantic CoreSchema with the IsoWeek pattern validation.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>type[Any]</code> <p>The source type to be converted.</p> required <code>handler</code> <code>GetCoreSchemaHandler</code> <p>The handler to get the CoreSchema.</p> required <p>Returns:</p> Type Description <code>CoreSchema</code> <p>A Pydantic CoreSchema with the IsoWeek pattern validation.</p> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: type[Self],\n    source: type[Any],\n    handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Return a Pydantic CoreSchema with the IsoWeek pattern validation.\n\n    Arguments:\n        source: The source type to be converted.\n        handler: The handler to get the CoreSchema.\n\n    Returns:\n        A Pydantic CoreSchema with the IsoWeek pattern validation.\n    \"\"\"\n    return core_schema.with_info_before_validator_function(\n        cls._validate,\n        core_schema.str_schema(),\n    )\n</code></pre>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeekDate","title":"iso_week_date.pydantic.T_ISOWeekDate","text":"<p>               Bases: <code>str</code></p> <p>T_ISOWeekDate parses iso week date in the ISO 8601 format.</p> <p>New in version 1.2.0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt; from iso_week_date.pydantic import T_ISOWeekDate\n&gt;&gt;&gt;\n&gt;&gt;&gt; class Model(BaseModel):\n...     isoweekdate: T_ISOWeekDate\n</code></pre> <pre><code>&gt;&gt;&gt; model = Model(isoweekdate=\"2024-W01-1\")\n&gt;&gt;&gt; model\nModel(isoweekdate='2024-W01-1')\n</code></pre> <pre><code>&gt;&gt;&gt; _ = Model(isoweekdate=\"2024-W53-1\")\nTraceback (most recent call last):\n...\npydantic_core._pydantic_core.ValidationError: 1 validation error for Model\nisoweekdate\n  Invalid week number. Year 2024 has only 52 weeks. [...]\n</code></pre> <pre><code>&gt;&gt;&gt; _ = Model(isoweekdate=\"abc\")\nTraceback (most recent call last):\n...\npydantic_core._pydantic_core.ValidationError: 1 validation error for Model\nisoweekdate\n  Invalid iso week date pattern [...]\n</code></pre> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>class T_ISOWeekDate(str):  # noqa: N801\n    \"\"\"T_ISOWeekDate parses iso week date in the [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date) format.\n\n    !!! info \"New in version 1.2.0\"\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt; from iso_week_date.pydantic import T_ISOWeekDate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Model(BaseModel):\n        ...     isoweekdate: T_ISOWeekDate\n\n        &gt;&gt;&gt; model = Model(isoweekdate=\"2024-W01-1\")\n        &gt;&gt;&gt; model\n        Model(isoweekdate='2024-W01-1')\n\n        &gt;&gt;&gt; _ = Model(isoweekdate=\"2024-W53-1\")\n        Traceback (most recent call last):\n        ...\n        pydantic_core._pydantic_core.ValidationError: 1 validation error for Model\n        isoweekdate\n          Invalid week number. Year 2024 has only 52 weeks. [...]\n\n        &gt;&gt;&gt; _ = Model(isoweekdate=\"abc\")\n        Traceback (most recent call last):\n        ...\n        pydantic_core._pydantic_core.ValidationError: 1 validation error for Model\n        isoweekdate\n          Invalid iso week date pattern [...]\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: type[Self],\n        source: type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Return a Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n        Arguments:\n            source: The source type to be converted.\n            handler: The handler to get the CoreSchema.\n\n        Returns:\n            A Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n        \"\"\"\n        return core_schema.with_info_before_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n        )\n\n    @classmethod\n    def _validate(cls: type[Self], /, __input_value: str, _: core_schema.ValidationInfo) -&gt; Self:\n        \"\"\"Validates iso week date string format against ISOWEEKDATE_PATTERN.\"\"\"\n        _match = ISOWEEKDATE_PATTERN.match(__input_value)\n\n        if not _match:\n            raise PydanticCustomError(\"T_ISOWeekDate\", \"Invalid iso week date pattern\")  # noqa: EM101\n\n        year, week = int(_match.group(1)), int(_match.group(2)[1:])\n\n        if (weeks_in_year := weeks_of_year(year)) &lt; week:\n            raise PydanticCustomError(\n                \"T_ISOWeekDate\",  # noqa: EM101\n                \"Invalid week number. Year {year} has only {weeks_in_year} weeks.\",\n                {\"year\": year, \"weeks_in_year\": weeks_in_year},\n            )\n\n        return cls(__input_value)\n</code></pre>"},{"location":"api/pydantic/#iso_week_date.pydantic.T_ISOWeekDate.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source: type[Any], handler: GetCoreSchemaHandler) -&gt; CoreSchema\n</code></pre> <p>Return a Pydantic CoreSchema with the IsoWeekDate pattern validation.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>type[Any]</code> <p>The source type to be converted.</p> required <code>handler</code> <code>GetCoreSchemaHandler</code> <p>The handler to get the CoreSchema.</p> required <p>Returns:</p> Type Description <code>CoreSchema</code> <p>A Pydantic CoreSchema with the IsoWeekDate pattern validation.</p> Source code in <code>iso_week_date/pydantic.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: type[Self],\n    source: type[Any],\n    handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Return a Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n    Arguments:\n        source: The source type to be converted.\n        handler: The handler to get the CoreSchema.\n\n    Returns:\n        A Pydantic CoreSchema with the IsoWeekDate pattern validation.\n\n    \"\"\"\n    return core_schema.with_info_before_validator_function(\n        cls._validate,\n        core_schema.str_schema(),\n    )\n</code></pre>"},{"location":"user-guide/dataframe-modules/","title":"Dataframe modules","text":"<p>The <code>pandas_utils</code> and <code>polars_utils</code> modules provide the same API to work with <code>pandas.Series</code> and <code>polars.Series</code>/<code>polars.Expr</code> respectively.</p> <p>The utilities come in two flavors: functions and extensions.</p>"},{"location":"user-guide/dataframe-modules/#functions","title":"Functions","text":"<p>The functions approach takes the series/expr as an argument and returns a new series/expr.</p> <p>Available functions are:</p> <ul> <li><code>datetime_to_isoweek</code> and <code>datetime_to_isoweekdate</code>: converts a <code>datetime</code> series to an ISO week (date) series.</li> <li><code>isoweek_to_datetime</code> and <code>isoweekdate_to_datetime</code>: converts an ISO week date series to a <code>datetime</code> series.</li> <li><code>is_isoweek_series</code> and <code>is_isoweekdate_series</code>: checks if a series is an ISO week (date) series.</li> </ul> pandas<pre><code>import pandas as pd\nfrom datetime import date, timedelta\nfrom iso_week_date.pandas_utils import (\n    datetime_to_isoweek,\n    isoweek_to_datetime,\n    is_isoweek_series,\n)\n\ns_date = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ndatetime_to_isoweek(series=s_date, offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n\ns_iso = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\nisoweek_to_datetime(series=s_iso, offset=pd.Timedelta(days=1))\n\"\"\"\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n\"\"\"\n\nis_isoweek_series(s_iso)  # True\nis_isoweek_series(s_iso + \"abc\")  # False\n</code></pre> polars<pre><code>import polars as pl\nfrom datetime import date, timedelta\nfrom iso_week_date.polars_utils import (\n    datetime_to_isoweekdate,\n    isoweekdate_to_datetime,\n    is_isoweekdate_series,\n)\n\ns_date = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\", eager=True)\ndatetime_to_isoweekdate(s_date, offset=timedelta(days=1)).to_list()\n# ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n\ns_iso = pl.Series([\"2022-W52-1\", \"2023-W01-2\", \"2023-W02-7\"])\nisoweekdate_to_datetime(series=s_iso, offset=timedelta(days=1))\n\"\"\"\ndate\n2022-12-27\n2023-01-04\n2023-01-16\n\"\"\"\n\nis_isoweekdate_series(s_iso)  # True\nis_isoweekdate_series(s_iso + \"abc\")  # False\n</code></pre>"},{"location":"user-guide/dataframe-modules/#extensions","title":"Extensions","text":"<p>On the other hand the extensions<sup>1</sup> approach extends the <code>pandas.Series</code> and <code>polars.Series</code>/<code>polars.Expr</code> classes with new methods.</p> <p>The extensions are available through the <code>iwd</code> (isoweekdate) namespace, and the methods available are the same as the functions.</p> <p>\"Translating\" the previous examples to extensions:</p> pandas<pre><code>import pandas as pd\nfrom iso_week_date.pandas_utils import SeriesIsoWeek  # noqa: F401 (1)\n\ns_date = pd.Series(pd.date_range(date(2023, 1, 1), date(2023, 1, 10), freq=\"1d\"))\ns_date.iwd.datetime_to_isoweek(offset=pd.Timedelta(days=1)).to_list()\n# ['2022-W52', '2022-W52', '2023-W01',..., '2023-W01', '2023-W02']\n\ns_iso = pd.Series([\"2022-W52\", \"2023-W01\", \"2023-W02\"])\ns_iso.iwd.isoweek_to_datetime(offset=pd.Timedelta(days=1))\n\"\"\"\n0   2022-12-27\n1   2023-01-03\n2   2023-01-10\ndtype: datetime64[ns]\n\"\"\"\n\ns_iso.iwd.is_isoweek(s_iso)  # True\ns_iso.iwd.is_isoweek(s_iso + \"abc\")  # False\n</code></pre> <ol> <li> <p>The import of <code>SeriesIsoWeek</code> is needed to register the extensions.</p> <p>noqa: F401 is added to avoid the linter(s) warning about the unused import.</p> </li> </ol> polars<pre><code>import polars as pl\nfrom iso_week_date.polars_utils import SeriesIsoWeek  # noqa: F401 (1)\n\ns_date = pl.date_range(date(2023, 1, 1), date(2023, 1, 10), interval=\"1d\")\ns_date.iwd.datetime_to_isoweekdate(offset=timedelta(days=1)).to_list()\n# ['2022-W52-6', '2022-W52-7', '2023-W01-1',..., '2023-W01-7', '2023-W02-1']\n\ns_iso = pl.Series([\"2022-W52-1\", \"2023-W01-2\", \"2023-W02-7\"])\ns_iso.iwd.isoweekdate_to_datetime(offset=timedelta(days=1))\n\"\"\"\ndate\n2022-12-27\n2023-01-04\n2023-01-16\n\"\"\"\n\ns_iso.iwd.is_isoweekdate()  # True\n(s_iso + \"abc\").iwd.is_isoweekdate_series()  # False\n</code></pre> <ol> <li> <p>The import of <code>SeriesIsoWeek</code> is needed to register the extensions.</p> <p>noqa: F401 is added to avoid the linter(s) warning about the unused import.</p> </li> </ol> <p>Note</p> <p>Polars extension is valid for both <code>Series</code> and <code>Expr</code> classes.</p> <p>This means that it is possible to use the extension in any polars context in which it would be possible to use an expression.</p> <ol> <li> <p>Extending pandas and polars \u21a9</p> </li> </ol>"},{"location":"user-guide/features/","title":"Features","text":"<p>This is a high level overview of the features provided by the <code>iso-week-date</code> package.</p>"},{"location":"user-guide/features/#isoweek-and-isoweekdate-classes","title":"<code>IsoWeek</code> and <code>IsoWeekDate</code> classes","text":"<p>The <code>IsoWeek</code> and <code>IsoWeekDate</code> classes both provide the following functionalities:</p> <ul> <li>Parsing from string, date and datetime objects</li> <li>Conversion to string, date and datetime objects</li> <li>Comparison operations between <code>IsoWeek</code> (resp <code>IsoWeekDate</code>) objects</li> <li>Addition with <code>int</code> and <code>Iterable[int]</code> types</li> <li>Subtraction with <code>int</code>, <code>IsoWeek</code> (resp <code>IsoWeekDate</code>), and <code>Iterable[int | IsoWeek]</code> types</li> <li>Range between two <code>IsoWeek</code> (resp. <code>IsoWeekDate</code>) objects</li> <li><code>__next__</code> method to generate the next <code>IsoWeek</code> (resp. <code>IsoWeekDate</code>) object</li> </ul> <p><code>IsoWeek</code> unique methods/features:</p> <ul> <li><code>days</code> properties that lists the dates in the given week</li> <li><code>nth</code> method to get the nth day of the week as date</li> <li><code>in</code> operator and <code>contains</code> method to check if a (iterable of) week(s), string(s) and/or date(s) is contained in the given week</li> <li><code>weeksout</code> method to generate a list of weeks that are n_weeks after the given week</li> <li>Addition and subtraction with <code>int</code> defaults to adding/subtracting weeks</li> </ul> <p><code>IsoWeekDate</code> unique methods/features:</p> <ul> <li><code>day</code> property that returns the weekday as integer</li> <li><code>isoweek</code> property that returns the ISO Week of the given date (as string)</li> <li><code>daysout</code> method to generate a list of dates that are n_days after the given date</li> <li>Addition and subtraction with <code>int</code> defaults to adding/subtracting days</li> </ul>"},{"location":"user-guide/features/#pandas-and-polars-utils","title":"pandas and polars utils","text":"<p><code>pandas_utils</code> and <code>polars_utils</code> modules provide functionalities to work with and move back and forth with series of ISO Week date formats.</p> <p>In specific both modules implements the following functionalities:</p> <ul> <li><code>datetime_to_isoweek</code> and <code>datetime_to_isoweekdate</code> to convert a series of datetime objects to a series of ISO Week (date) strings</li> <li><code>isoweek_to_datetime</code> and <code>isoweekdate_to_datetime</code> to convert a series of ISO Week (date) strings to a series of datetime objects</li> <li><code>is_isoweek_series</code> and <code>is_isoweekdate_series</code> to check if a string series values match the ISO Week (date) format</li> </ul>"},{"location":"user-guide/features/#custom-offset","title":"Custom offset","text":"<p>One of the main reason for this library to exist is the need and the flexibility to work with custom offsets, i.e. to be able to add/subtract a custom offset (as <code>timedelta</code>) to the default ISO Week start and given date, and get a \"shifted\" week.</p> <p>This feature is available both in the <code>IsoWeek</code> and <code>IsoWeekDate</code> classes and the dataframe functionalities.</p> <p>To check an example see the working with custom offset section.</p>"},{"location":"user-guide/pydantic/","title":"Working with Pydantic","text":"<p>If you want to work with ISO Week (date) format within pydantic v2, i.e. create a model with a string field representing an ISO Week (date) format, there are two options: the easy way and the hard proper way.</p>"},{"location":"user-guide/pydantic/#the-easy-way","title":"The easy way","text":"<p>The easy way to achieve this is via <code>Annotated</code> and <code>StringConstraints</code> with custom regex patterns.</p> <p>The regex patterns are available in the top level module of iso-week-date, therefore it is possible to use them directly:</p> <pre><code>from typing import Annotated\n\nfrom iso_week_date import ISOWEEK_PATTERN, ISOWEEKDATE_PATTERN\nfrom pydantic import BaseModel, StringConstraints\n\nT_ISOWeek = Annotated[str, StringConstraints(pattern=ISOWEEK_PATTERN.pattern)]\nT_ISOWeekDate = Annotated[str, StringConstraints(pattern=ISOWEEKDATE_PATTERN.pattern)]\n\n\nclass MyModel(BaseModel):\n    week: T_ISOWeek\n    week_date: T_ISOWeekDate\n\n\nm1 = MyModel(week=\"2023-W01\", week_date=\"2023-W01-1\")\nm2 = MyModel(week=\"2023-W53\", week_date=\"2023-W01-1\")\n</code></pre>"},{"location":"user-guide/pydantic/#caveat","title":"Caveat","text":"<p>The caveat of this approach can be seen in the second instance in the example above. Namely the regex patterns could be not strict enough for your purposes, i.e. they allow for some combinations that are not valid ISO Week (date) formats.</p> <p>In fact not every combination of year and week number should be possible (not every year has 53 weeks!), but this is not enforced by the regex patterns.</p> <p>Note</p> <p>Remark that actual validation happens when instantiating <code>IsoWeek</code> and <code>IsoWeekDate</code> classes.</p> <p>On the positive side, python datetime module deals with that automagically:</p> <pre><code>from datetime import datetime\n\n# 2023 has 52 weeks\ndatetime.strptime(\"2023-W53-1\", \"%G-W%V-%u\")  # datetime(2024, 1, 1, 0, 0)\ndatetime.strptime(\"2024-W01-1\", \"%G-W%V-%u\")  # datetime(2024, 1, 1, 0, 0)\n</code></pre> <p>As we can see the datetime module is able to parse both <code>2023-W53-1</code> and <code>2024-W01-1</code> to the same datetime object (<code>datetime(2024, 1, 1, 0, 0)</code>).</p>"},{"location":"user-guide/pydantic/#the-proper-way","title":"The proper way","text":"<p>As of <code>iso-week-date==1.2.0</code>, we provide a <code>pydantic</code> submodule, which implements <code>T_ISOWeek</code> and <code>T_ISOWeekDate</code> custom types using custom validation with <code>__get_pydantic_core_schema__</code>.</p> <p>Such implementation requires pydantic v2.4.0+ and pydantic-core features, which are under fast and active development.</p> <pre><code>from iso_week_date.pydantic import T_ISOWeek, T_ISOWeekDate\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    week: T_ISOWeek\n    week_date: T_ISOWeekDate\n\n\nm1 = MyModel(week=\"2023-W01\", week_date=\"2023-W01-1\")  # All good here!\nm2 = MyModel(week=\"2023-W53\", week_date=\"2023-W01-1\")  # Raises ValidationError\n</code></pre> <pre><code>ValidationError: 1 validation error for MyModel\nweek\n  Invalid week number. Year 2023 has only 52 weeks. [type=T_ISOWeek, input_value='2023-W53', input_type=str]\n</code></pre>"},{"location":"user-guide/pydantic/#compact-formats","title":"Compact formats","text":"<p>The compact formats (YYYYWNN, YYYYWNND) are not directly available in the module. However if needed it is possible to composed them with some gymnastic:</p> <pre><code>from typing import Final\nfrom iso_week_date._patterns import (\n    YEAR_MATCH,\n    WEEK_MATCH,\n    WEEKDAY_MATCH,\n)  # These are strings, not regex patterns\n\nISOWEEK_COMPACT_PATTERN: Final[str] = r\"^{}{}$\".format(YEAR_MATCH, WEEK_MATCH)\nISOWEEKDATE_COMPACT_PATTERN: Final[str] = r\"^{}{}{}$\".format(\n    YEAR_MATCH, WEEK_MATCH, WEEK_DAY_MATCH\n)\n\nT_ISOWeekCompact = Annotated[str, StringConstraints(pattern=ISOWEEK_COMPACT_PATTERN)]\nT_ISOWeekDateCompact = Annotated[\n    str, StringConstraints(pattern=ISOWEEKDATE_COMPACT_PATTERN)\n]\n</code></pre>"},{"location":"user-guide/quickstart/","title":"Quickstart","text":"<p>In this section we will see how to work with the different modules of the library.</p> <p>For a high level overview of the features provided by the <code>iso-week-date</code> package, see the features section.</p> <p>For a detailed description of the API, see the API Reference section.</p>"},{"location":"user-guide/quickstart/#common-functionalities","title":"Common functionalities","text":"<p>As mentioned in the features section, the <code>IsoWeek</code> and <code>IsoWeekDate</code> classes share a lot of functionalities and methods (due to the common parent class <code>BaseIsoWeek</code>).</p> <p>Therefore we will focus first on the common functionalities, and then showcase the unique features of each class.</p> <p>Both these classes are available from the top-level module:</p> imports<pre><code>from datetime import date, datetime, timedelta\n\nfrom iso_week_date import IsoWeek, IsoWeekDate\n</code></pre>"},{"location":"user-guide/quickstart/#parsing-from-types","title":"Parsing from types","text":"<p>An instance can be initialized from parsing multiple types:</p> directly<code>from_string</code><code>from_compact</code><code>from_date</code><code>from_datetime</code><code>from_values</code> <pre><code>iw = IsoWeek(\"2023-W01\")  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate(\"2023-W01-1\")  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_string(\"2023-W01\")  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_string(\"2023-W01-1\")  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_compact(\"2023W01\")  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_compact(\"2023W01-1\")  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_date(date(2023, 1, 2))  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_date(date(2023, 1, 2))  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_datetime(datetime(2023, 1, 2, 12))  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_datetime(datetime(2023, 1, 2, 12))  # IsoWeekDate(\"2023-W01-1\")\n</code></pre> <pre><code>iw = IsoWeek.from_values(year=2023, week=1)  # IsoWeek(\"2023-W01\")\niwd = IsoWeekDate.from_values(2023, 1, weekday=1)  # IsoWeekDate(\"2023-W01-1\")\n</code></pre>"},{"location":"user-guide/quickstart/#conversion-to-types","title":"Conversion to types","text":"<p>On the \"opposite\" direction, an instance can be converted to multiple types:</p> <code>to_string</code><code>to_compact</code><code>to_date</code><code>to_datetime</code><code>to_values</code> <pre><code>iw.to_string()  # \"2023-W01\"\niwd.to_string()  # \"2023-W01-1\"\n</code></pre> <pre><code>iw.to_compact()  # \"2023W01\"\niwd.to_compact()  # \"2023W011\"\n</code></pre> <pre><code>iw.to_date()  # date(2023, 1, 2)\niwd.to_date()  # date(2023, 1, 2)\n</code></pre> <pre><code>iw.to_datetime()  # datetime(2023, 1, 2, 0, 0)\niwd.to_datetime()  # datetime(2023, 1, 2, 0, 0)\n</code></pre> <pre><code>iw.to_values()  # (2023, 1)  # (year, weeknumber)\niwd.to_values()  # (2023, 1, 1)  # (year, weeknumber, weekday)\n</code></pre> <p>IsoWeek to date/datetime</p> <p>Remark that <code>IsoWeek.to_date</code> and <code>IsoWeek.to_datetime</code> methods accept an optional <code>weekday</code> argument, which defaults to <code>1</code> (first weekday), and can be used to get the date of a specific day of the week:</p> specific weekday<pre><code>iw.to_date(2)  # date(2023, 1, 3)\niw.to_datetime(3)  # datetime(2023, 1, 4, 0, 0)\n</code></pre>"},{"location":"user-guide/quickstart/#comparison-operations","title":"Comparison operations","text":"<p>Both classes inherit all the comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>), which can be used to compare two instances of the same class:</p> <pre><code>iw == IsoWeek(\"2023-W01\")  # True\niw == iwd  # False\niw &lt; IsoWeek(\"2023-W02\")  # True\niwd &gt; IsoWeekDate(\"2023-W02-2\")  # False\niw &lt; iwd  # TypeError\n</code></pre> <p>To compare two instances we first check that they have the same parent class, then check they share the same offset value, and finally we compare their string value exploiting the lexical order of the ISO Week date format.</p>"},{"location":"user-guide/quickstart/#properties","title":"Properties","text":"<code>year</code><code>week</code> <pre><code>iw.year  # 2023\niwd.year  # 2023\n</code></pre> <pre><code>iw.week  # 1\niwd.week  # 1\n</code></pre>"},{"location":"user-guide/quickstart/#addition-and-subtraction","title":"Addition and subtraction","text":"<p>Classes inheriting from <code>BaseIsoWeek</code> have to implement:</p> <ul> <li>addition with <code>int</code> type.</li> <li> <p>subtraction with <code>int</code> and <code>Self</code> types (1)</p> <ol> <li>The <code>Self</code> type is the class itself, i.e. <code>IsoWeek</code> for <code>IsoWeek</code> and <code>IsoWeekDate</code> for <code>IsoWeekDate</code>.</li> </ol> </li> </ul> <p>operation with <code>int</code>s</p> <p>The two classes treat <code>int</code> type differently when performing addition and subtraction operations. Namely:</p> <ul> <li>For <code>IsoWeek</code> it is interpreted as weeks</li> <li>For <code>IsoWeekDate</code> it is interpreted as days</li> </ul> Addition <code>+</code>Subtraction <code>-</code> <pre><code>iw + 1  # IsoWeek(\"2023-W02\")\n\ntuple(iw + (1, 2, 3))  # (IsoWeek(\"2023-W02\"), IsoWeek(\"2023-W03\"), IsoWeek(\"2023-W04\"))\n\niwd + 1  # IsoWeekDate(\"2023-W01-2\")\n</code></pre> <pre><code>iw - 1  # IsoWeek(\"2022-W52\")\niw - IsoWeek(\"2022-W52\")  # 1\n\ntuple(iw - (1, 2, 3))  # (IsoWeek(\"2022-W52\"), IsoWeek(\"2022-W51\"), IsoWeek(\"2022-W50\"))\n\niwd - 1  # IsoWeekDate(\"2022-W52-7\")\niwd - IsoWeekDate(\"2022-W52-3\")  # 5\n</code></pre>"},{"location":"user-guide/quickstart/#range-method","title":"Range method","text":"<p><code>BaseIsoWeek</code> implements a classmethod to create range between two \"ISO Week\"-like objects that inherit from it and implement addition with <code>int</code> and subtraction between ISO Week objects.</p> range classmethod<pre><code>tuple(\n    IsoWeek.range(\n        start=\"2023-W01\", end=\"2023-W07\", step=2, inclusive=\"both\", as_str=True\n    )\n)\n# ('2023-W01', '2023-W03', '2023-W05', '2023-W07')\n\ntuple(\n    IsoWeekDate.range(\n        start=\"2023-W01-1\", end=\"2023-W03-3\", step=3, inclusive=\"left\", as_str=True\n    )\n)\n# ('2023-W01-1', '2023-W01-4', '2023-W01-7', '2023-W02-3', '2023-W02-6', '2023-W03-2')\n</code></pre>"},{"location":"user-guide/quickstart/#isoweek-specific","title":"<code>IsoWeek</code> specific","text":"<p>In addition to the common functionalities, the <code>IsoWeek</code> class provides additional properties and methods.</p>"},{"location":"user-guide/quickstart/#days-property","title":"Days property","text":"<p>The <code>days</code> property returns a tuple of <code>date</code>s in the given week:</p> <pre><code>iw.days  # (date(2023, 1, 2), date(2023, 1, 3), ..., date(2023, 1, 8))\n</code></pre>"},{"location":"user-guide/quickstart/#weeksout-method","title":"Weeksout method","text":"<p>The <code>weeksout</code> method generates a list of weeks that are n_weeks after the given week:</p> <pre><code>tuple(iw.weeksout(3))  # ('2023-W02', '2023-W03', '2023-W04')\ntuple(\n    iw.weeksout(6, step=2, as_str=False)\n)  # (IsoWeek('2023-W02'), IsoWeek('2023-W04'), IsoWeek('2023-W06'))\n</code></pre>"},{"location":"user-guide/quickstart/#contains-method","title":"Contains method","text":"<p>The <code>contains</code> method checks if a (iterable of) week(s), string(s) and/or date(s) is contained in the given week:</p> <pre><code>iw.contains(\"2023-W01\")  # True\niw.contains(date(2023, 1, 1))  # False\n\niw.contains(\n    (IsoWeek(\"2023-W01\"), date(2023, 1, 1), date(2023, 1, 2))\n)  # (True, False, True)\n</code></pre> <p>This is achieved by implementing the <code>__contains__</code> method, which is called when using the <code>in</code> operator:</p> <pre><code>date(2023, 1, 1) in iw  # False\ndate(2023, 1, 2) in iw  # True\n</code></pre>"},{"location":"user-guide/quickstart/#isoweekdate-specific","title":"<code>IsoWeekDate</code> specific","text":"<p>In a similar fashion, <code>IsoWeekDate</code> class provides additional properties and methods.</p>"},{"location":"user-guide/quickstart/#isoweek-specific-properties","title":"<code>IsoWeek</code> specific properties","text":"<p>We have two additional properties:</p> <ul> <li><code>isoweek</code> returns the ISO Week of the given date (as string)</li> <li><code>day</code>: returns the weekday as integer</li> </ul> <code>isoweek</code><code>day</code> <pre><code>iwd.isoweek  # \"2023-W01\"\n</code></pre> <pre><code>iwd.day  # 1\n</code></pre>"},{"location":"user-guide/quickstart/#daysout-method","title":"Daysout method","text":"<p>The <code>daysout</code> method generates a list of dates that are n_days after the given date:</p> <pre><code>tuple(iwd.daysout(3))  # ('2023-W01-2', '2023-W01-3', '2023-W01-4')\ntuple(iwd.daysout(6, step=3, as_str=False))\n# (IsoWeekDate('2023-W01-2'), IsoWeekDate('2023-W01-5'), IsoWeekDate('2023-W02-1'))\n</code></pre>"},{"location":"user-guide/quickstart/#working-with-custom-offset","title":"Working with custom offset","text":"<p>The \"standard\" ISO Week starts on Monday and end on Sunday. However there are cases in which one may require a shift in the starting day of a week.</p> <p>The <code>IsoWeek</code> class has one class attribute called <code>offset_</code> which can be used to define a custom offset for the week.</p> custom offset<pre><code>class MyWeek(IsoWeek):\n    \"\"\"\n    MyWeek class is a IsoWeek with custom offset of -2 days.\n    Therefore MyWeek starts the Saturday before the \"standard\" ISO week.\n    \"\"\"\n\n    offset_ = timedelta(days=-2)\n</code></pre> <p>This is all that is required to work with a custom shifted week.</p> <p>Now the same date may be \"mapped\" to different ISO Weeks depending on the offset:</p> <pre><code>_date = date(2023, 1, 1)\nIsoWeek.from_date(_date)  # IsoWeek(2022-W52)\nMyWeek.from_date(_date)  # MyWeek(2023-W01)\n</code></pre> <p>Or we can see that the same week starts on different dates:</p> <pre><code>IsoWeek(\"2023-W01\").nth(1)  # date(2023, 1, 2)\nMyWeek(\"2023-W01\").nth(1)  # date(2022, 12, 31)\n</code></pre> <p>Similarly we can define a custom offset for the <code>IsoWeekDate</code> class:</p> custom offset<pre><code>class MyWeekDate(IsoWeekDate):\n    \"\"\"\n    MyWeekDate class is a IsoWeekDate with custom offset of -2 days.\n    Therefore MyWeekDate starts the Saturday before the \"standard\" ISO week.\n    \"\"\"\n\n    offset_ = timedelta(days=-2)\n</code></pre> <p>All the functionalities still work as expected, just keep in mind that comparisons and arithmetic operations will be available only on instances with the same offset.</p>"}]}